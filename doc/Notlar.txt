15.11.2022

Java Eğitimi

Java Ders programı
Salı - Perşembe
Saat: 19:00 - 22:00


github'ta ders notları yedeklenecek.


1- Java Genel giriş 
2- Java özellikleri
3- Genel programlama pradigmaları
4- Sayı sistemleri
5- Bir java programı text sayafasına yazıp derleyip çalıştıracaz


HW1
-Assembly nedir neden var neden kullanımda hala?
-Unity ve Unreal Engine nedir ve diger oyun motorlarına inceleyelim.
-Interpereted programlama dili nedir?
-Garbage Collector Nedir nasıl çalışır?
-Memory leak
-Functional Programming, Prosedürel Programlama, Object Oriented Programming,
    Generic Programming, Imperative programming, Reflective programming, Concurrent
-Java programı derleme ve çalıştırma adımları
    JVM nedir 
    JRE nedir 
    JIT nedir 
    Byte code nedir 

    Bunlar hangi aşamalardan geçerken kullanılıyor?



ali olustur 
..
..

ali silindi progaramcı silmesin ben silerim G.C devereye giriyor 

C ve C++ da Garbage C. mekanizması yoktur. Programcı kendi siler kendi olsuturdugu nesneyi.


Programlama Dillerinin Sınıflandırılması

Programlama dillerini 3(üç) biçimde sınıflandırabiliriz:
1. Seviyelerine göre sınıflandırma

2. Kullanım alanlarına göre sınıflandırma

3. Programlama modeline göre sınıflandırma



Java programı derleme ve çalıştırma adımları





--------------------------------------------------------

HW2 

Stack ve Heap Nedir ?
Donanımsal karsılıkları?

Fonksiyonel programlama ile prosüdürel programlama arasındaki fark?
Imperative Programing?
Reflective programing?
Concurrent programing? 


--------------------------------------------------------
22.11.2022


HW3 
Github reopsu olusturmak kendi java norları için
Github'a kendini anlatan bilgi veren sade bir Overwiev olustur.
Google documentler den slaytları hazırlayalım

--------------------------------------------------------
/*******************************************************/
/*******************************************************/


Sayı Sistemleri 


2-8-10-16 temelde bu sayı sistemleri var 


2 lik sayı sistemi 

Neden kullanırız: tam sayı ve gerçek sayı sistemleri için kullanırız

4 66 76  -- 123,4 555.7


0101 1011 0001 1110 

ikilik  sayı sistemi işaretli ve işaretsiz olmak üzer iki gruba ayrılır 

işaretsiz - unsigned --> sayının pozitif oldgunu söyleer
işaretli -- signed ---> sayıların hem pozitif hem negatif olabiliceğini söyler 


Sistemlerin hemen hepsinde 

8 bitlik alana byte denilmektedir.

bit bit bit bit bit bit bit  bit
1   0   1    0   1   1   0   0  === byte 

bit = binary digit 
Byte = 8bit

Sistem programlamada daha küöçük birimler var 

4 bit = Nibble = yarım byte
8 bit = byte 
2 byte = word
4 byte = double word


Sayı sistemlerinde bazı işlemler

2'ye tümleyeni bulma konusu için pratik kurallar 

	0101  0100
	1010	 1100

sagdan baslayarak ilk 1 bitini gorene kadar 
bitlerin aynısını yazıyoruz
geri kalan kısmı ters ceviriyoruz
	

	0001  1000
     1110  1000    

---------------------
işaretli 2 lik sistem

sign bit --> sayının işaretni belirler
0 --> pozitif sayı
1 --> negatif sayı


işaretli sayı sistemlerinde 
Sistemlerin hemen hepsi negatif sayıyı gösterimi için
Sayının 2'ye tümleyini aritmatigi kullanır

aynı sayıınn pozitif ve negatif degerleri
sayının 2 ye tümlenyenleri

45
-45 gibi 

1110 1001 = -23
2^0 * 1 + 2^1 * 0 + 2^2 * 0 + 2^3 * 1 + 2^4 * 0 + 2^5 * 1 + + 2^6 * 1 + 2^7 * 1
0001 0111 = 23


Soru :  bir byte lık alanda -52 sayısını ifade edermisin

önce 52 degerinin bitlerini buluruz sonrada 2'ye tümelyeni buluruz. Eksili sayının 2 bitlik ifadesini 

0011 0100 = 52
1100 1100 = -52


---------------------------------------------
temel byte alanlarında yazılabilecek en buyuk ve en kucuk degerler 

unsigned sistemde

0  - 255
0  - 65535
0  - .....


signed sistemlerde

0111 1111 -- > 127 en buyuk tam sayı degeri 
1000 0001 ---> -127 - 1 = 128 en kucuk tam sayı degeri elde edilir 
1000 0000 --> -128


-128 127
-32768 - 32767
-2147483648  - 2147483647 

--------------------------------------------------------------

Soru: İşaretli 2 lik sayı sisteminde butun bitleri 1 olan sayı nedir

1111 1111 = -128 + 127 = -1
0000 0001 = 1 


--------------------------------------------------------------

16 LIK sayı sistemi 

hexadecimal sistem 
hex system denir 

16 tane sembol var

0123456789ABCDEF


Neden hex sistemi bizi ilgilendirir

aslında 2 lık sayı sisteminde 5 bitlik alanı tekbir yerde gosterebiliriz
ayrıca 16 lık sistem 2 nın katı olması işimizi kolaylaştırır



Soru: 2lık sayı sistemini 16 lık sayı sistemine cevirelim

1001  1110 1001 1111
  9    E    9    F

Soru:  1AC  onluk sayı sistemine donusturelim

1*16^2 + 10 * 16^1 + 12 * 16^0  = 256 + 160 + 12 = .....


-----------------------------------------------------------

Önce java gereksinimleri yuklenmeli işletim sistemine göre

Sonra 
Java ayarlarımızı consol'dan incelemeliyiz aynı versiyon olmalı  

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>java -version
java version "17.0.1" 2021-10-19 LTS
Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>javac -version
javac 17.0.1

-----------------------------------------------------------


Dil kavramı nedir?

Dil iletiişmde kullanılan semboller toplulugudur. Bir dilin kurallarına gramer denir.
Gramerin bir çok alanı vardır. En önemlileri "sentaks (syntax) " ve "semantik (semantic" dir.
Bir cümlenin olabilmesi için en azından sentaks ve semantiğe sahip olması gerekir.


Sentaks doğru yazma ve dogru dizilime ilişkin kurallardır.

		"I going to will fitness."

Java ornegi 

		System.out.println("Hello, World)";


Semantik: Dildeki dogru dizilmiş ögelerin ne anlama ifade ettiketlerine ilişkin kurallara da semantik denir.


Dipnot:
Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar bilimlerinde kullanılmak üzere tasarlanmış
dillere bilgisayar dilleri (computer langues) denir. Bir bilgisayar dilinde akış da varsa o zaman programalam dili
(programmin language) denir. Örnek: HTML, XML gibi bilgisayar dilleridir, programlama dili değildir.
C, C++, Java, C#, Swift..... gibi dillerde akış oldugunda programlama dilleridir. 


-----------------------------------------------------------

Hello World Program


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}


komutlar

-> javac orhn/App.java

-> java orhn.App


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

29.11.2022 Salı

Derleyici hata mesajları (diagnostics):

1. Gerçek hatalar (Error): Dilin sentaks ve semantik kurallarına uyulmamasından dolayı verilen mesajlardır.
	Bu durumda arakod(Byte code) üretilmez.

2. Uyarılar (warning): Byte kodun üretimine engel olmayan, olası programlama ve mantık hatalarının programcıya
	bildirilmesi içien verilen mesajlardır. Programcı bu uyarıları mutlaka dikkate almalıdır. Özel bir durum yoksa 
	uyarı mesajlarının oluşumuna yol açan kodlar düzeltilmelidir. Bazı duurmlarda derleyicinin uyarı mesajı verdiği ancak IDE'nin kullanıldıgı
	bir "static kod analizi araçları" konfigürasyonları gereği uyarı verebilirler. Şüphesiz bunlarda da dikkate alınmalıdır. Ancak bunların
	hepsi düzeltilmesi gerekmez.


3. Ölümcül hatalar (fatal errors): Derleme işleminin bile tamamlanmasını engelleyebilecek hatalardır. Bu durumda
	programcının yazdıgı kod açısından yapacak bir şeyi yoktur. Çünkü kod henüz derlememiştir. Programcının ölümcül hataya
	yol açan durumu ortadan kaldırmsı gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar ölümcül hatalara örnek gösterilebilir.


Programın çalışma zamanı sırasında oluşan hatalara genel olarak "exception" denir. Exception oluştugunda program sonlanır. 
Bu durum detayları "exception işlemleri(exception handling)" konusunda ele alınacaktır. Excepiton yerine "run time error" da kullanılabilrmektedir. 
"error" denildiginde "compile time error" anlaşılır.
  

-----------------------------------------------------------

Java'da yorum satırları (comment lines)


Not: Yorum satırları kodun okunabilirliğini/algılanabilirliğini bozacak şekilde koda eklenmemelidir
	Yorum satırı eklemenin de bir "convetion"'u olmadır.

package orhn;

class App{

    //Burası derleyici tarafından dikkate alınmaz.
    public static void main(String[] args) {
        System.out.println("Hello, World");    

        /*
            Burası da 
            derleyici
            tarafından 
            dikkate alınmaz 
         */
    }
}

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Atom (Token):
Bir programlama dilinde kendi başına anlamlı olan en küçük birime atom denir. Atomlar 6 gruba ayrılır.

1. Anahtar Sözcükler(keywords, reserved words): Dil için özel bir anlamı olan yeni dil tarafın bilinen ve 
	birçoğu doğrudan değişken ismi olarak kullanılamayan atomlardır. Örneğin: package, class, public, int, if, while vs.

2. Değişkenler (identifiers, variables): İsmini programcının belirlediği ve çeşitli kurallara göre isminin berlirlenebildiği atomlardır.
	Örneğin: App, String, System, orhn vs...

3. Operatörler (Operators): Bir işleme yol açan ve bu işlem sonucunda bir değer üreten atomlardır.
	Örneğin: a + b ifadesinde + bir operatordür

4. Sabitler (Literals, constants): Program içerisine doğrudan yazılan sayılara denir. Örneğin: a - 5 ifadesinde
	5 bir sabittir. 

5. String'ler (Strings, String Literals): iki tırnak (double quote) içersinde bulunan yazılar tırnaklarla birlikte string atomudur.
	Bu atoma string sabiti anlamında "string literal" da denir. Örneğin: "Hello, World"

6. Ayraçlar (delimiters, punctuators): Yukarıdaki gruplar dışında kaln tüm atomlara denir. Örneğin: {}, (), [] vs.

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Programı atomlarına parçalayalım


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}

package 		->  anahtar sözcük
orhn			-> değişken
class		-> anahtar sözcük
App			-> değişken
{}			-> ayraç
public		-> anahtar sözcük
static		-> anahtar sözcük
void 		-> anahtar sözcük
main			-> metod ismi değişken
()			-> ayıraç
String		-> değişken
[]			-> ayıraç 
args			-> değişken
{}			-> ayıraç
System		-> değişken
.			-> operator
out			-> değişken
println		-> değişken
()			-> metod çagırma operatoru
"Hello, World" -> String literals
;			-> Ayıraç


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Boşluk karakterleri (whitespaces): Klavyeden basılıgında bosluk algısı veren karakterlerdir.
	Klavyeden basılan bosluk karakterleri tipik olarak sunlardır: space, tab, enter 

-----------------------------------------------------------
-----------------------------------------------------------

	Java programlama dilinde kod yazım kuralları şunlardır:
	1. Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.
	2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.


-----------------------------------------------------------
-----------------------------------------------------------

Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.


package 



orhn;

class 







App{

    public static void main(String[


    ] 
    
    args) 
    
    {
        System.             out.            println("Hello, World");    

    }
}


-----------------------------------------------------------
-----------------------------------------------------------

2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		


package orhn;class App{public static void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.

package orhn;class App{publicstatic void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Not: Java'da derleme zamanı (compile time) ve çalışma zamanı (run time) denilen birbiriyle ilişkili
	ancak ayrı olan iki kavram vardır. Derleme zamanı derleme sürecinde yapılan işlemlere denir. 
	Çalışma zamanı programın çalışma sürecinde yapılan işlemlere denir.

-----------------------------------------------------------
-----------------------------------------------------------

Bildirim (declaration): Bildirim bir ismin derleyiciye tanıtılmasıdır. 
				    Derleyici bildirim ile o ismin ne anlama deldiğini anlar ve derleme işlemini ona göre yapar.


-----------------------------------------------------------
-----------------------------------------------------------

Bir java programı genel olarak paketlerden, paketler sınıflardan, sınıflarda metodlardan oluşur.

package <isim>;
Örnek:
package orhn;


class <isim> {


}

Örnek:

class Sample{
	//...
}


class Mample{
	//...
}





-----------------------------------------------------------
-----------------------------------------------------------
Metod bildirimlerin genel biçimi:

Java'da alt programlara metot (method) denir. Alt programın ne yapacağının yazılmasına "metot bildirimi (metot declaration)" denir.
Alt programın kodlarının çalıştırılmasına ise "metot çağırma (method call)" denir. Metot bildirimini genel biçimi:

[erişim belirleyici] [static/non-static] <geri dönüş değeri bilgisi> <metot ismi>([parametreler])
{
	//...
	//...

}

Açıklamalar:

-Erişim belirlemeleri şunlardan biri olabilir: public, protected, private, no-modifier(hiçbir şey yazılmaması)
	Metotların erişim berlirleyicileri konusuna gelene kadar tüm metodları public olarak bildirecez.

- Bir metot static veya non-static olabilir. static anahtar sözcüğü bildirimde yazılmasa metot non-static olur.
	non-static metotlara ilişkin konuya gelene kadar tüm metotları static olarak bildirecez.

- Metodun geri dönüş değeri bilgisi metot isminden önce yazılmalıdır. Metodun geri dönüş değerinin olmaması durumuda
	void yazılması demektir. Geri dönüş degerı kavramı da ileride ele alınacaktır.
- Metodun ismi bir değişken atomdur. Tğm değişken atomlarda oldugu gibi "değişken isimlendirme kuralları"na uygun 
	olarak isimlendirilmelidir.
-Metot bildirimlerinde motot isminden sonra parantezler içerisinde ismine "parametre (parameter)" deniken değişkenler bildirilebilir.
	Metot parametre değişkenleri ileride ele alınacaktır.
- Metot bildiriminde küme paratezleri arasında (metot gövdesi) metodun kodları yazılır 


static bir metodun çağrılmasının genel biçimi:

[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);


Bir program main metodunun çağrılmasıyla çalışmaya başlar. Programcının main metodu içerisinde çağırdığı motolar ve o metotların içerisinde çağrılan motolarla
akış devam eder. main metodu JVM tarafından çağrılır. Bu anlamda java programına verilen "byte code"'a ilişkin sınıfın main metoduna "giriş noktası (entry point)"
denir. Özel bazı özel durumlar dışında (bu özel durumlar vardı - extrem konularda karsımıza cıkar) main metodu sonlandıgında program sonlanır.
Bir metot çağrıldıgında akış metodun kodlarına dallanır (call) ve metodun kodları çalıştırılır. Şüphesiz metot içerisinde başka bir metot çağrılıyor olabilir.
Yine bu çapırma n0oktasında akıl metodun kodlarına dallanır. Metot çağrısı sonlandıgında akış metodun çağrıldıgı noktaya geri döner ve bir sonraki koddan akış 
çalışmaya devam eder.

Not: System.out.println("Hello World"); çağrısında System bir sınıf, out bir referans ve println de non-static bir metotdur.
	Bu kavramları ileride ele alacagız.

-----------------------------------------------------------
-----------------------------------------------------------

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        orhn.Sample.foo();
        orhn.Sample.bar();
        orhn.Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        orhn.Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------

Çağıran metodun (caller) ait oldugu sınıf ile çağıran metot (callee) ait oldugu sınıf 
aynı paket içerisindeyse çağırma sırasında paket ismi yazılmayabilir

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}
-----------------------------------------------------------
-----------------------------------------------------------
Çağıran metot ile çağrılan metot aynı sınfta ise bu durumda çağırma sırasında paket ismi yazılmamışsa sınıf 
ismide yazılmayabilir.

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
        foo();
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------
01.12.2022 Perşembe

IDE (Integrated Development Environment): Derleyiciler komut satırından çalıştırlabilen basit bir arayüze sahip
programlardır. Aslında teorik olarak java ile geliştirilecek bir uygulma içerisinde tüm java dosyları "notepad"
basit bir editor ile yazılıp, komut satırından derlenebilir. Fakat pratikte bu şekilde program yazman fazlaca 
zaman kaybettirir. Yazılım geliştirmeyi kolaylaştırmak için IDE debilen programlar kullanılır.
IDE'ler içerisinde editorler, test araçları, çeşitli kodlar üreten araçlar vs. bulunur. IDE bir derleyici değildir.
IDE derleme işlemi için derleyiciyi de çalıştırabilir. Uygulamayı çalıştırma işlemi için de yineJRE içerisindeki araçları 
kullanabilir. Java ile uygulma geliştirirken kullanılabilecek çeşitli IDE'ler bulunmaktadır. Bunlardan en yaygın 
kullanılanları "Eclipse" ve "IntelliJ IDEA" IDE'leridir. Önceleri Netbeans isminde bir IDE kullanılmaktaydı. 
Ancak Netbeans kullanımı oldukça azalmıştır.

-----------------------------------------------------------
-----------------------------------------------------------
Tür (type): Bir değişken için bellekte kaç byte ayrılacağını ve içerisindeki hangi
yöntemle veri tutulacagını belirten kavramdır.

Java'da türler genel olarak iki gruba ayrılabilir.
Temel türler (primitive/built*in/predefined types).
Programcının tanımladığı türler (user defined types).


Temel türler

Tür ismi			Uzunluğu(byte)
short				2
int					4
long				8
byte				1                           0 0 0 0  0 1 0 1  --> 5    ------- -128/127

float				4
double				8

char				2
boolean				-


-Java da türlerin uzunlukları boolean türü dışında sistemden sisteme değişmez.

-Tüm tam sayı türleri işaretlidir(signed)

-Tamsayı türleri (integer/integral types) için ikiye tümleme yöntemi kullanılır. Java'da işaretsiz tam sayı türleri yoktur.
Ancak java 8 ile birlikte belirli koşullar altında işaretsiz tamsayı işlemleri yapılabilmektedir.

-long türü en uzun tamsayı türüdür.

-Gerçek sayı(real/floating point types) için "IEEE 754 standardı" kullanılır. float ve double türleri sırasıyla
tek hassasiyetli (single precision) ve çift hassasiyetli (double precision) değerleri tutmaktadır. Bu türlerde bazı sayılar
tam olarak ifade edilemezler 0 sayıya yakın bir sayı ile ifade edilebilirler. Bir noktalı sayının ifade edilemeyip en yakın
sayı olarak ifade edilmesine yuvarlama hatası (rounding error) denir. Yuvarlama hataları değer ilk kez yerleştirilirken
de oluşabilir, bir işemin sonucunda da oluşabilir.


-Gerçek sayı türleri işaretli türlerdir.

-float türünün yuvarlama hatalarına karşı direnci zayıfır. Yanı yuvarlama hatası daha çok olmaktadır.

-Yuvarlama hataları parasal ve finansal uygulamarda hatalı değerlerin oluşmasına sebep olabilir. Sırf parasal
ve finansal uygulamalar için tasarlanmış özel türler (sınıflar) bulunur. Programcı böylesi uygulamalar için bu sınıfı
tercih eder. Ancak bu sınıflar yuvarlama hatası yapmamak için yüzlerce makine komutu ile bu işlemleri yapar.
Bu durumda programcı için parasal ve finansal uygulamalar gibi yuvarlama hatasının olmaması gerekn uygulamalar dışında double
yada durma göre float türü tercih edilmelidir.


-char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türünden 
değişken içerisinde bir karakterin UNICODE tablosu (ya da başka tablodaki) sıra numarası tutulur. UNICODE tablo
dünyadaki dillerde kullanılan hemen hemen tüm karakterleri ve bazı özel karakterleri ifade edebilme yeteneğine sahiptir.


-Yazılar içerisinde her bir karakter aslında bir sayı ile temsil edilir. Hangi karakterin hangi sayı ile ifade edildiği
karater tablosuna bağlıdır. ASCII tablosu 1 byte'lık yani 256 tane satırdan oluşur. UNICODE tablo 2 byte'lık
yani 65536 satırdan oluşan bir tablodur. Karakter tablolları bunlarla sınırlı değildir.


-boolean türünün alabileceği iki tane değer vardır: true, false. boolean türünün uzunluğu "Java Language Specification"'da
belirtilememiştir. Sistemden sisteme değişebilir. Ancak bu değişim programcı açısından problem oluşturmaz.

Not: int türüne "integer" demek yanlış bir terim kullanamk demektir. integer terimi tamsayılar için
kullanılan genel bir terimdir. Ayrıca "Integer" isimli bir sınıf da bulunmaktadır.

Not: Java'da en çok kullanılan tamsayı türü int türüdür. en çok kullanılan gerçek sayı türü de double türüdür.
Programcı öncelikle bu türleri tercih etmelidir. Eğer geçerli bir nedeni varsa diğer türleri kullanabilir.

-----------------------------------------------------------
-----------------------------------------------------------
HW3

IEEE 754 standardı nedir? 
Gerçek sayılar bu standarda göre nasıl ifade edilir?

1344.3454 ---> bunun sistemde nasıl ifade edildiği 
		   veya javada nasıl ifade edildiğini ögrenecez


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
Bir değişken kullanılmadan önce bildirilmelidir:
Değişken bildiriminin genel biçimi:
<tür> <değişken ismi>;

örnek:

int a;
float b;
boolean c;

-----------------------------------------------------------
-----------------------------------------------------------
Java'da 3 çeşit değişken vardır:
1. Yerel değişkenler (local variables)
2. Parametre değişkenleri (Parameter variables)
3. Sınıf veri elemanları (class member variables)


Değişkenler için temel kavramlar:
İsim(name): Belli kurallara göre yazılan karakterler topluluğudur.

Tür (type): Değişken için bellekte ne kadar yer ayrılacağı ve içerisinde değerlerin hangi yönteme göre tutulacağını belirtir.

Faaliyet alanı (scope): Bir değişken isminin derleyici tarafından görülebildiği kod aralığıdır. Derleme zamanına işilkindir.

Ömür (storage duration): Bir değişkenin bellekte kalma süresidir. Çalışma zamanına ilişkindir.

Temel bazı kavramlar:
Blok (block): Bir metot içerisinde { ile } arasında kalan kod bölümüdür. Metodun gövdesi de bir bloktur.

İlkdeğer verme (initialization): Bir değişkene bildirim noktasında verieln değer denir. 

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bir metot içerisinde istenildiği kadar ayrı veya iç içe bloklar olabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		{
			//...
			
			{
				//..
			}
		}
		
		{
			//...
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		{
			//...
			
			{
				double b;
				int c;
				//..
			}
		}
		
		{
			float d;
			//...
		}
	}
}

class Sample{
	public static void foo()
	{
		int x;
		
		//..
		{
			//..
			boolean f;
			//..
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı türden yerel değişkenler aralarında virgül konarak bildirilebilirler
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		double x, y, z;
	}
}

class Sample{
	public static void foo()
	{
		int x, y, z;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yerel değişkenlere ilkdeğer verme
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //ilk deger verme
		double pi = 3.14; //ilk degerveme sentaksı
	}
}

class Sample{
	public static void foo()
	{
		int x = 10, y = 30, z;
		
		z = 33;//initizlization değil.... 
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Yerel bir değikenin faaliyet alanı bildirildği yerden bildirilği bloğun sonuna kadardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x;
			
			x = 20;
			
			//..
			
			{
				x = 45;
			}
		}
		
		x = 15; //error
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		int a;
		double a; //error
		//..
	}
	
	public static void bar() 
	{
		int a;
		
		{
			double a; //error
			//..
			
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Farklı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçerlidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x = 10;
			//..
		}
		
		{
			int x = 20;
			//..
		}
		
		int x = 30;
		
		//..
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değer verilmemiş hiçbir değiken kullanılamaz. Yani içerisindeki değer işleme sokulamaz
 * Yerel değişkenlere değer verilmesi programcının sorumluluğundadır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		int b;
		
		b = a * 2; //error
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * print ve println metotları değişkenlerin içerisindeki değerleri ekrana basarlar
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		System.out.print(a); //ekrana yazdırır
		System.out.println(a); //--> print("") sonrada alt satıra geçiririm 
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimleri sayısal bir karakter ile başlamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int 1number; //error
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri herhangi bir uygun karakter ile başlatılıp istenildği kadar sayısal karater içerebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a12345 = 10; 
		
		System.out.println(a12345);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede UNICODE alfabetik karakterler kullanabiliir. Örneğin türkçe karakter geçerlidir ,
 * 
 * Not: Her ne kadar değişken isimlendirmede UNICODE karakterler kullanılabildse de programlamada yalnızca
 * İngilizce alfabetik 26 karakterin kullanılması iyi bir tekniktir. Biz de bu "convention"' a uygun kodlar yazacağız.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int öğrencisayısı = 10; 
		
		System.out.println(öğrencisayısı);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimlendirmede boşluk (whitespace) karakterleri geçersizdir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int number Of Students = 10; 
		
		System.out.println(number Of Students);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri büyük-küçük harf duyarlıdır (case-sensitive)
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int val, Val, VaL, VAL; //geçerli  
		
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede  _(underscore/ alttire) karakteri kullamabilir. Hatta değişken ismi _ karateri ile başalatılabilir.
 *
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int _11 = 20;
		int _val = 22;
		int number_of_students = 11;
		
		System.out.println(_11);
		System.out.println(_val);
		System.out.println(number_of_students);
		
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 9 ile birlikte alttire karaterinin tek başına değişken ismi olarak kullanıması geçersizdir. 
 * Java 8 ile birlikte "deprecated" olmuştur.
 * 
 * 
 * Not: Programlamda "artık kullanılması tavsiye edilmeyen" durumlar için "deprecated" terimi kullanılır.
 * Bu durum gerekçeleri farklı farklı olabilir. Programcı açısından genel olarak "deprecated" olan bir durum özel bir takım
 * nedenler yoksa tercih edilmemelidir.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int _ = 10; //error
		
		System.out.println(_);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değişken isimlendirme $ karakteri kullanılabilir. Hatta isimler $ karakteri ile başlayabilir. $ karakteri
 * tek başına değişken ismi olabilir. Ancak programcı açısından değişken isimlendire $ karakteri kullanılmamalıdır.
 * Derleyici ismini kendisinin belirlediği durumlarda isimlendirmede bu karateri kullanır. $ karakteri bu anlamada
 * programcı tarafından kullanılırsa iism çakışması olabilir. Zaten $ karaterinin varlık sabebi de bu
 * tip kod üretimlerinde kulllanılmasıdır.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int amountOf$s = 1000;
		int $ = 35;
		double $123 = 123;
		
		System.out.println(amountOf$s);
		System.out.println($);
		System.out.println($123);
		
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Anahatar sözcükler tek başına değişken ismi olarak kullanılamaz. Ancak Java'ya daha sonra eklenmiş yerine göre
 * anahtar sözcük biçiminde kullanılan bazı atomlar vardır. Bu tarz eklenen sözcükler tam anlamıyla anahtar sözcük değildir.
 * Kullanıldığı yere göre değişken ismi olup olmadığı derleyici tarafından tespit edilir (inference, deduction). 
 * Bu tarz sözcüklere programlamada "bağlamsal anahtar sözcük (contextual keywords") de denir.
 
 
 	Not: Değişken isimlerinin kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta olması gerekir.
 	
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		//int double; //error
		//double package; //error
		
		var a = 10;
		
		int var = 20;
		
		System.out.println(var);
		System.out.println(a);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

06.12.2022 Salı


/*
 * Macar notasyonu
 * Camel case(lower camel case): numberOfCase
 * Pascal Case(upper camel case): SerialPort
 * snake case (unix style): number_of_students
 * 
 * 
 * Java coding style 
 * 
 */
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Klavyeden temel türden degerler okuma yöntemlerinin tam anlamı ileride detaylı olarak ele
 * alınacak. Bu sebeple bunları bir kalıp olarak görüp yalnıca kalyeden okuma kısmı ile ilgilenecez.
 * 
 * 
 * Klavyeden int türden değer okunması kalıbı
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden int türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
 * Klaveyden double türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		
		double result = a * b;
		
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden long türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		long b = Long.parseLong(kb.nextLine());
		
		
		long result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden float türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		float a = Float.parseFloat(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		float b = Float.parseFloat(kb.nextLine());
		
		
		float result = a * b;
		
		System.out.println(result);
		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar Konusu
 * 
 * ifade(expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir dizilime ifade denir.
 * Değişkenler ve sabitler tek başına ifade belirtebilirken, operatorler tek başına ifade olamazlar. İstisna bir durum dışında
 * ifadeler hesaplandığında bir değer üretirler.
 * 
 *  a + b
 */

/*
 * Bir metodun geri dönüş degeri bilgisi yerine bir tür ismi yazılırsa bu metodun "geri dönüşü vardır" denir. 
 * Tersine bir metodun geri dönüş degeri varsa geri dönüş degeri bilgisi yerine bir tür ismi yazılır. 
 * Bir metodun geri dönüş deger varsa metot çağrısı bittikten sonra çağrıuldığı noktaya bir değer ile geri döner.
 * Bir metodun geri dönüş değeri yoksa geri dönüş değeri bilgisi yerine void anahtar sözcüğü yazılır. 
 * Bir metodun geri dönüş değeri metot içerisinde return  deyimi ile oluşturulur. 
 * 
 * return deyiminin genel biçimi:
 *  		return [ifade];
 *  
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Yani metot içerisinde akış return deyimine geldiğindemetot sonlanır 
 * ve akış çağrılan noktaya geri döner. return deyimine ilişkin ifadenin değeri çağıran metoda aktarılır.
 *  
 */


/*
 * Aşağıdaki örnekte add metodunun geri dönüş değeri 3 ile çarpılmış ve sonucu result değişkenine atanmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}






-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Java derleyicisi genel olarak bir deyime akışın hiçber zaman gelemeyeceğini anlarsa o yazılan
 * deyim için error oluşturur (unreachable code).
 */

/*
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Aşağıdaki örnekte return deyiminden sonra 
 * akış metot içerisinde kalmayacağından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
		
		System.out.println("Unreachable Code");
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * akış return deyimine geldiğinde return deyimine ilişkin ifade önce hesaplanır, elde edilen değer döndürülür
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Geri dönüş değeri olan metotolarda (void olmayan metotlarda )return tek başına kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return; //error		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur.
 * Aşaığıdaki örnekte result 10 değerinden küçük veya eşitise metot bir değer döndürmeyeceğinden error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		if(result > 10)
			return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici geri dönüş değerinin çağıran metoda aktarımı geçici değişken yaratan bir kod üretir. 
 * Aşağıdaki ** ile belirtilen kod parçası için derleyicinin ürettiği temsili kod şu şekildedir:
 * 
 * 			int temp = a + b;
 * 
 * 			returlt = temp * 3;
 * 
 * Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun
 * geri dönüş değerinin türü ile aynıdır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3; //**
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		return a + b; // int temp = a + b;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *Geri dönüş değeri olan metotolar geri dönüş degeri işleme sokulmayacak şekilde çağrılabilirler. 
 *Şüphesiz metodun da tasarımı bu kullanım açısından anlamlı olmalıdır. Aşağıdaki örnekte add metotdu klavyeden alınan 
 *değerlerin toplamını ekrana basıp aynı zamanda da değere geri dönmektedir. Programcı kodda metodun sadece ekrana basmasıyla ilgilenmiş
 *ve geri dönüş değerini kullanmamıştır. Şephesiz başka bir çağrıda kullanaılabilir.
 *
 *
 *Metot ekrana toplam değerini basmasaydı bu şekilde çağırma uygun olurmu? (işimize yararmıydı)?
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		System.out.println(result);
		
		return result;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bir metodun geri dönüş değeri başka bir motdun geri dönüş değeri olarak verilebilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getAdd();
		
		System.out.println(result);
	}
}

class Util{
	public static int getAdd()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte yine add metodunun geri dönüş değeri bir işleme sokulmuştur 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getResult();
		
		System.out.println(result);
	}
}

class Util{
	public static int getResult()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add() * 2;
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return deyimi zorunlu değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return istenirse metodu sonlandırmak için tek başına kullanılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	void metotlarda return deyimi ifade ile kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return 10; //error
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda geri dönüş değeri varmış gibi çağrılamaz. Yani void metot çağrısı geri dönüş varmış gibi işleme sokulamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.printAdd(); //error
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metot'larda parametre değişkenleri
 *
 * Metot bildirimlerinde metot isminden sonra parantezler arasında bildirilen değişkenlere "metot parametre değişkenleri"
 * ya da "parametre değişkneleri" denir. Bir metodun parametre değişkeni olmayabilir ya da istenildiği sayıda virgül ile 
 * ayrılarak bildirlebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a, int b)
	{
		//..
	}
	
	public static void printSquare(int a)
	{
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	bir metodun parametre değişkenleri aynı türden olsa bile tür bilgisi yazılmalıdır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  b) //error
	{
		//..
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenleri faaliyet alanı bakımıından metot başında bildirilen yerel değişkenler gibidir.
 * Dikkat bu cümle sadece faaliyet alanı bakımından aynı oldujlarının söylüyor. Sonuçta yerel değişken ile 
 * parametre değişlkeni aynı değildir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenlerine değerler metot çağrılır iken verilir. Metot çağırlırken bir parametreye verilen
 * ifadeye "argüman" denir. Bir metot kaç tane parametre sahipse o kadar sayıda arguman ile çağrılmalıdır. 
 * Argumanlardan parametrelere aktarım da bir atam işlemidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x, y);
		
		int result = NumberUtil.square(x);
		
		System.out.println(result);		
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metot parametre saysı kadar argüman ile çağrılmalıdır. Aksi durumda error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x); //error
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Metot çağrısında bir argüman ilişkin ifade önce hesaplanır, elde edilen değer ile metot çağrılır. Birden fazla
 *  parametreye sahip bir metot çağrısında tüm argümanlara ilişkin ifadeler hesaplanır, elde edilen değeler ile metot çağrılır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun parametre değişkeni ya da değişkenleri hem de degeri dönüş degeri olabilir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.square(NumberUtil.add(x, y));

		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir.
 *  Bu tip "compact" çözümler kodun okunabilirliğini / algılanabilirliğini etkilememelidir. Gerekirse ayrı ayrı hesaplanacak 
 *  şekilde yazılmalıdır.
 *
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.square(NumberUtil.add(x - 6, y - 5)));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	bir önceki örnek okunabilirlik/algılanabilirlik açısından aşağıdaki gibi de yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int total = NumberUtil.add(x - 6, y - 5);
		int result = NumberUtil.square(total);
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.add(x, y));
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(NumberUtil.add(x, y));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 * 
 * 
 * kötü kod bu şekilde yazılması daha doğru
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar ne işe yarar= Ya da başka bir deyişle bir problemin çözümünde neden metotlar yazalım?
 * 
 * - Bir işi çok fazla yerde yapmak kod tekrarına yol açar. Yazılım geliştirmede temel prensip "zorunlu olmadıkça
 * 	 kod tekrarı yapılmamalıdır (do not repeat yourself)" şeklindedir. Bu durumda programcı örneğin bir metot yazar ve ilgili yerlerde bu metodu çağırır.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde  "implemente" edilmişse, bu durumda programcı
 *  problemin bir değişiklik yapmak isterse veya bir hata oldgunda anlayıp düzeltmek isterse her yerde bu değişilikleri yapmak zorunda kalacaktır. 
 *  Bu çoğu zman zor olabilir.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
 *   kodun okunabilirliği de azalabilir. Yani metot çağırarak kodun okunabilirliği de artmış olur.
 * 
 * - Metot yazıldıgında başka projelere taşınarak da kullanılabilir. (code re-usability)
 * 
 * - Metodu çağıran programcı metodun nasıl yazışdıgına ilişkin detayları bilmek zorunda değildir. Çünkü metodun
 *   çağrıldığı noktada metodun nasıl yazıldıgının önemi yoktur.
 *   
 *   
 *   Not: İleride ele alacağımız "nesne yönelimli programalama tekniği"'ne ilişkin kavramlar ile kodun parçalara ayrılması metotlar
 *   dışında daha yüksek seviyede de yapılabilmektedir. Yani kabaca bu tarz programlamanın temelinde metotlar vardır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * System.out.printf metodunun ilk argümanı String olmalıdır. Metot bu argüman dışında istenilen sayıda ve istenilen türde
 * argüman ile çağıralabilir. Metodun birinci parametresine ilişkin argümanda % karateri ile birlikte geçerli
 * bazı karakterler kullanıldıgında "yer tutucu (place holder)" belirtişmiş olur. % ile birlikte kullanıma
 * "format belirleyici (format specifiers)" da denir. % birlikte kullanılan geçerli karatere ise "format karateri" denir.
 * Metot yer tutucular yerine diğer geçilen argümanlara ilişkin degerleri yerleştirir ve ekrana bu yazıyı basar. 
 * Bazı format karaterleri bir argümana ilişkin değere karşılık gelmez. Özel anlamları vardır.
 * 
 * 
 * Not: printf gibi değişkeb sayıda argüman alabilen metotlara "variadic methods" denir. 
 * Buarada bu tarz metotların nasıl yazıldıgı ele alınmayacaktır.
 * 
 */


/*
 * Tamsayı türlerinin (short, int, long, byte) decimal olarak formatlanması  d format karateri kullanılır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int degree = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece", degree);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda imleci bir sonraki starın başına geçirmek için %n kullanılabilir. %n bu anlamda bir argümana karşılık gelmez
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Arasınav notunuzu giriniz : ");
		int midtermGrade = Integer.parseInt(kb.nextLine());
		
		System.out.print("Final notunuzu giriniz : ");
		int finalGrade = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("Arasınav : %d%nFinal: %d%n", midtermGrade, finalGrade);
		System.out.println("Geçme notrunuz hesaplanıyor!....");
		//...
		//..
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodu x, X, h, H format karaterleri ile tamsayi türlerine ilişkin değerler hexadecimal olarak formatlanabilir.
 * Ayrıca o format karateri ile tamsayı türlerine ilişkin değerler octal olarak formatlanabilir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %x%n", val);
		System.out.printf("val = %X%n", val);
		System.out.printf("val = %h%n", val);
		System.out.printf("val = %H%n", val);
		System.out.printf("val = %o%n", val);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %-8d  %10d%n", val, val);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte  %08X yer tutucu için 
 * yazıulan karater sayısı 8'den kucukse geri kalanlar için sıfır yazılır 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %8d%n", val);
		System.out.printf("val = %-8d  %8d%n", val, val);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%02d/%02d/%04d%n", day, mon, year);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%2d/%02d/%4d%n", day, mon, year);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
08/12/2022

/*
 * printf metodunda gerçek sayılar (folat ve double) için f format karateri kullanılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %f%n", dval);

	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda  f format karateri ile ondalık kısmın kaç basamak olarak formatlanacağı 
 * aşagıdaki gibi belirtilebilir.
 * Geri kalan basmaklar bilimsel olarak yuvarlanır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %.3f%n", dval);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  char türü için c format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 3333;
		
		System.out.printf("c = %c%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  boolean türü için b format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  uygun format karakterlei kullanılmadıgında genel olarak exception oluşur.
 * 
 * Bu durumun istisnaları var
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %d%n", flag);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda s format karateri ile tür ne olursa olsun formatlanabilir. Şüphesiz bu durumda türe özgü
 * biçimler (hizalama vs) kullanılmaz. Bu format karakterinin ayrıntıları ileri ele alınacak
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 3.4;
		boolean c = true;
		char d = 67;
		
		System.out.printf("a = %s, b = %s, c = %s d= %s%n", a, b, c, d);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda % karakterinden sonra uygun bir format karateri getirilmelidir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %  %f%n", ratio);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda % karakteri için iki tane % karateri kullanılmalıdır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %%%f%n", ratio);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
Not: printf metodunun format karakterleri ve kullanım biçimleri oldukça geniştir. 
Burada sadece temel olanlar ele alınmıştır. Diğer format karakterleri ve kullanım biçimleri konular içerisinde ele alınacaktır.
-----------------------------------------------------------
-----------------------------------------------------------

Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
	
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindSumMultiplyApp.run();
	}
}

class FindSumMultiplyApp{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));
		System.out.printf("%d * %d = %d%n", a, b, NumberUtil.multiply(a, b));
		
	}
}

class NumberUtil{
	public static int add(int a, int b)
	{
		return a + b;
	}
	
	public static int multiply(int a, int b)
	{
		return a * b;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bölme işlemi tamsayılar ile yapıldıgında sonuç her zaman tamsayı çıkar. Elde edilen sayının noktadan sonraki kısmı
 * yuvarlanmadan atılır.
 * 
 * Tamsayılar ile bölme işleminde paydanın sıfır olması durumnda exception olusur
 * 
 * .Bu durumların detayları ileri ele alınacak
 * 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		double result = a / b;
		
		System.out.printf("%d  / %d = %f%n", a, b, result);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * format metot du ile printf tamamen aynı işlemi yapar
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.format("%d  %d %n", a, b);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 	Gerçek sayılar ile bölme işleminde payda sıfır olsa da işlem yapılır. Yani bir exception oluşmaz. Gerçek sayılar
	içerisinde genel olarak Matematik'teki "belirsizlik" için kullanılan "Not a number (NaN)" değeri vardır. Ayrıca
	genel olarak sonsuzluk (Matematik'teki tanımsızlık) için kullanılan -Infinity ve +Infinity değerleri de vardır. 
	Bu özel değerler dışında da başka özel değerler vardır. Bu durumda gerçek sayılar ile bölme işleminde pay sıfırdan
	farklı, payda sıfır ise payın işaretine göre + veya - Infinity, pay ve paydanın ikisi birden sıfır ise NaN sonucu
	elde edilir 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
		
		double result = a / b;
		
		System.out.printf("%f / %f = %f%n", a, b, result);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 	Neden standart metoları kullanmalıyız? Yani standart olarak var olan metodu programcı yazmalımıdır?
 * 	Java da standart olarak (JavaSE) bulunan metotların kullnılmasının bazı önemli avantajları varıdr:
 * 
 * 	-okunabilir kodlar yazılır
 *  -Testleri yapılmıştır ve yeterince etkin olarak yazılmıstır
 *  -Taşınabilir
 *  -Bazı metotlar (ki bunların sayısı oldukca fazladır) baska detay konularıda bilmeyi gerektirir
 *  -Programcının projede sadece kendi konusna odaklanmasıı saglar
 *  
 *   Bu durumda bir Java programcısı çözmesi gereken bir problem için JavaSE'de problemin çözümüne ilişkin metotlar varsa
 *	 onları kullanmalıdır. Yoksa yazma işlemine girişmelidir. Ancak bu druum programcının standart kullandığı metotların
 *	 nasıl yazıldığını gözardı etmesi anlamına gelmez. Programcı programlama yaşamı boyunca hepsini olmasa da hazır olarak
 *	 kullandıklarının nasıl gerçekleştirilebileceğini öğrenmelidir
 */

/*
 * Math sınıfı abs metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı sqrt metodu: Metot negatif degerler için NaN degerine geri döner
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
		
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dx = x1 - x2;
		double dy = y1 - y2;
		
		return Math.sqrt(dx * dx + dy * dy);
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfın PI ve E elemanları
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının trigonometrik işlem yapan metotları radyan ölçü birimi ile çalışır
 * 
 * Radyan ve derece arasındaki dönüşümler için toRadians ve toDegrees metotoları kullanılabilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("value: ");
		double value = Double.parseDouble(kb.nextLine());
		
		System.out.printf("sin(%f) = %f%n", value, Math.sin(Math.toRadians(value)));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f) = %f%n",a ,b ,Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n",a ,b ,Math.max(a, b));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, Math.max(Math.max(a, b), c));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.min(a, b, c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.max(a, b, c));
	}
}

class MathUtil{
	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}
	
	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f, %f) = %f%n", a, b, MathUtil.log(a, b));
	}
}


class MathUtil{
	public static double log(double a, double b) {
		return Math.log10(b) / Math.log10(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));
		System.out.printf("ceil(%f) = %.20f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %.20f%n", a, Math.floor(a));
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------,
	Sabitler (literals, constants)
	Program içerisinde doğrudan yazılan sayılara denir. Sabitlerin de türleri vardır. Derleyici sabitlerin türlerini 
	tespit ederek işlem yapar.
	
	Sabitlerin türlerinin tespitine ilişkin detaylar:
	- Sayı nokta içermiyorsa, sonuna bir ek almamışsa ve int türü sınırları içerisindeyse int türdendir. Sayı int türü
	sınırları içerisinde değilse error oluşur. 
	Örneğin: 100, 2000, 2000000000
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa long türdendir. Sayı long türü sınırları
	dışındaysa error oluşur. 
	Örneğin: 10L, 4000000000L
	
	Anahtar Notlar: Küçk harf L kullanımı 1(bir) rakamanına benzemesinden dolayı programlamada tercih edilmez. 
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve sonuna bir ek almamışsa double türdendir. Sayı double olarak ifade edilemiyor ise
	error oluşur
	Örneğin: 3.4, 6.7
	
	- Sayı nokta içersin ya da içermesin sonunda D (küçük ya da büyük) eki varsa double türdendir.
	Örneğin: 3D, 10d, 30.56D
	
	- Sayı nokta içersin ya da içermesin sonunda F (küçük ya da büyük) eki varsa float türdendir.
	Örneğin: 3F, 2f, 3.4F
	
	- boolean türden iki tane sabit vardır: true, false
	
	- char türden sabitler: İki tane tek tırnak karakteri arasında yazılan bir karakter, karakter tablosunda sıra 
	numarası belirtir. Bu şekilde yazılan sabitlere "karakter sabitleri (character literals)" denir ve bu sabitler char
	türdendir. İki tane tek tırnak karakteri arasında özel durumlar dışında birden fazla karakter yazımı geçersizdir. 
	
	Bazı karakterlerin klavyeden basılması doğrudan derleyici tarafından karakter olarak algılanamaz. Hatta bazı
	karakteler "non-printable"'dır. Örneğin bir sonraki satıra geçme karkaterinin karakter sabiti doğrudan yazılamaz.
	Bu tip bazı karakterler klavyeden doğrudan yazılamazlar. Bu tarz karakterlerin karakter sabitleri iki tane tek
	tırnak içerisinde ters bölü karakteri ile onu takip eden özel bir karakter biçiminde yazılır. Bu şekilde yazılan
	karakterlere "escape sequence" karakterler denir. Hatta bazı karakterler hem normal hem de ters bölü ile yazılabilirler:
	Java'da desteklenen escape sequence karakterler şunlardır:
	
	'\n' -> line feed (LF) 
	'\r' -> carriage return (CR)
	'\t' -> horizontal tab
	'\b' -> backspace
	'\f' -> form feed
	'\0' -> null karakter
	'\"' -> double quote (optional)
	'\'' -> single quote
	'\\' -> back slash  
----------------------------------------------------------------------------------------------------------------------*/

/*
 * char türden sabitler
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'D';
		
		System.out.println(c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * iki tane tek tırnak arasında birden fazla karater yazımı özel durumlar dışında geçersizdir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'De'; //error
		
		System.out.println(c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Line feed karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\n';
		
		System.out.printf("Marhaba");
		System.out.print(c);
		System.out.printf("Nasılsın ");
		System.out.printf("Ali");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Carriage return karater sabiti: 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\r';
		
		System.out.printf("Marhabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Horizontal tab karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\t';
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.print(c);
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Backspace karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\b'; 	
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\nNasılsın\nİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\rİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch1 = '"';
		char ch2 = '\"';
		
		System.out.println(ch1);
		System.out.println(ch2);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * İki tırnak karateri string atomu içerisinde ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\"Merhaba Ali, nasıl gidiyor\"");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Tek  tırnak karateri string atomu içerisinde dogrudan ya da ters bölü ile kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("'Merhaba Ali, nasıl gidiyor\'");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
13.12.2022 Salı


/*
 * Tek  tırnak karater sabiti ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\'';
		
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape karakterlerinden dolayı istenilen sonuç elde edilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *yukarıdaki problem aşağıdaki gibi çözümlenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\\testdata\\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *ters bölü karakterinden sonra özel karakterler dışında yazılan karakter error olusturur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *\\\\192.168.1.21\\testdata\\orhan.txt yol ifadesi "String literal" içerisinde yazılması gerek
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\\\\192.168.1.21\\testdata\\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  tek tırnak karakteri değildir -- backtick
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '`';
				
		System.out.println(ch);
		System.out.println("`Orhan OZTURK`");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü ve u karakteri ile bir karakterin sıra numarası hexadecimal olarak tek tırnak içerisinde yazıldıgında
 *  o karatere ilişkin karater sabiti yazılmış olur. Burada hexadecimal sayı kesinlikle iki byte olarak yani
 *  4 tane hex digit olarak yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\u00CB';
				
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter sabitleri "string literal" atomu içerisinde de kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Orhan OZTURK : \u1788");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter değişken isimlendirmede de kullanılabilir. Şüphesiz pratik değildir.
 *  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int \u0041\u0042\u00CB = 10;

		System.out.println(AB\u00CB);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  bir tamsayının ön eki yoksa bu durumda sabit "decimal" olarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik ıkarak sıfır ve x (buyuk ve kucuk farketmez) yazıldıgında ekten sonra gelen 
 *  basamaklar  "hexadecimal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0xA;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik sıfır yazıldıgında ekten sonra gelen 
 *  basamaklar  "octal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 012;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------


/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0b1010;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki örnekte SensorUtil sınıfının out metodu 16 tane pini olan bir elektronik devre için aldığı argüman 
	değerine göre değerin bit'lerin karşılık gelen pinleri 1 ya da sıfır için "high" ya da "low" seviyeye çekiyor olsun.
	Bu durumda böyle bir metodun alacağı sabit argümanın "binary" veya "hexadecimal" olarak yazılması okunabilirliliği
	artırır. Ayrıca yazım kolaylığı da sağlar. Aşağıdaki demo örneği yukarıdaki senaryoya göre düşününüz   
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 1.3E10;
		double b = 1.3e10;
		double c = 1.3E+10;
		double d = 1.3e+10;
		double e = 1.3E-10;
		double f = 1.3e-10;
		
		
		System.out.printf("a  = %f%n", a);
		System.out.printf("b  = %f%n", b);
		System.out.printf("c  = %f%n", c);
		System.out.printf("d  = %f%n", d);
		System.out.printf("e  = %.12f%n", e);
		System.out.printf("f  = %.12f%n", f);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double avogadroConstant = 6.02E23;
		
		System.out.println(avogadroConstant);
		System.out.printf("%f%n", avogadroConstant);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0xFC_AB_CD;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_456_123_000L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_______________________________________8L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 0b10101010_10101011_10101010_0011L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = _67; //error
		b = 43_; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sayı nokta içerisiyorsa noktadan hemen önce veya sonra alttire geçilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 6_.4; //error
		b = 4._4; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a, b;
		
		a = 5000000000L_; //error
		b = 5000000000_L; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabit önündeki eklerdeb önce sonra yada ekler arasına konulamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = 0x_AB; //error
		b = _0xAB; //error
		c = 0_xAB; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * alttire karateri octal sabitler için önek ile (sıfır ile) ilk basamak arasında geçerlidir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0_12;
		
		System.out.println(a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gerçek sayı sabitlerinin tamsayı kısmının degeri sıfır ise noktadan nce sıfır yazılmayabilir.
 * Benze şekilde sayının noktadan sonraki kısmının tamamı sıfır ise yibe sıfır noktadan sonra yazılmayabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a, b;
		
		a = .3;
		b= 3.;
		
		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yalnızca sabitlerden ve operatörleden oluşan yani içerisinde değişken olmayan ifadelere "sabit ifadesi (constant expression)" denir.
 * Buy anlamda sabit de tek başına bir sabit ifadesidir.
 * 
 * 
 * Not: İleride aslında sabit ifadesi olark kullanılabilen değişkenler de göreceğiz. Bu tarz değişknler de
 * bir ifade içersinde sabit olarak ele alınır.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		b = 20;
		
		System.out.println(NumberUtil.add(a - 2, b)); //argümanların hiçbiti sabit ifadesi değil
		System.out.println(NumberUtil.add(10 + 5, 89 - 8)); //argümanların hepsi sabit ifadesi 
	}
}

class NumberUtil{
	public static int add(int a, int b) {
		return a + b;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Derleyiciler sabit ifadelerinin değerlini hesaplayarak sonucu "byte code" a yazarlar. Bu optimizasyona
 * "constant folding optimizasyonu" denir. Bu sebeple aşağıdaki kodda 1000L * 60 * 60 * 24 * 365 ifadesinin
 * değeri byte code'a 31536000000 şeklinde yazılır. Aşağıdaki örnekte bilgi kaybı olmaması için 1000 sabitini 
 * long olarka yazılmıstır. Konuya ileride değinecez.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365; //byte code --> long divider = 31536000000;
		
		System.out.println(divider);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
			Operatörler
			
	Operatörler: Bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör denir. Operatör ile
	birlikte işleme giren ifadelere "operand" denir.
	
	Operatörleri 3(üç) biçimde sınıflandırılabilir:
	1. İşlevlerine göre sınıflandırma
		- Aritmetik (arithmetic) operatörler
		- Karşılaştırma (comparison) operatörleri
		- Mantıksal (logical) operatörler
		- Bitsel (bitwise) operatörler
		- Özel amaçlı (special purpose) operatörler	
	2. Operand sayısına göre sınıflandırma
		- Tek operandlı (unary)
		- İki operandlı (binary)
		- Üç operandlı (ternary)	
	3. Operatörün konumuna göre sınıflandırma
		- önek (prefix)
		- araek (infix)
		- sonek (postfix)
		
	Operatörün kısıtı (constraint)
	Operatörün ürettiği değer (product value)
	Operatörün yan etkisi (side effect) var mı?
	Operatörün önceliği (precedence):
	
	a = b + c * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: c * d
	i2: b + i1
	i3: a = i2
	
	a = (b + c) * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 * d
	i3: a = i2	
	
	a = b + c - d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 - d
	i3: a = i2
		
	Not: Java programcısı bir operatör için yukarıdaki durumları bilmelidir. Yani bir operatörün öğrenilmesi
	o operatör için yukarıdaki durumların bilinmesi anlamına gelir.	
	
	Not: Bazı operatörler öncelik kuralına doğrudan uymazlar. Bu tarz operatörlerin de uymadıkları durum için
	nasıl çalıştıklarının bilinmesi gerekir. Şüphesiz bu operatörlerin neden öncelik kurallarına uymadıklarının da 
	gerekçeleri (rationale) bulunur.
	
	
	Not: Operatör öncelik tablosu gruplandırma olarak düşünülebilir. Yani operatör öncelik tablosundaki öncelik
	durumlarının yapılış biçimine ilişkin istisnaları olabilir. Şüphesiz bunun da bilinmesi gerekir. Operatör öncelik
	tablosu algısal bakımdan kolaylaştırmak için vardır ve önemlidir.	

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Artimetik 4 işlem ve mod operatörleri iki operandlı (binary) ve araek (infix) operatörlerdir.
 * Bu operatörlerin ürettileri değer işlemin sonucunda elde edilen değerdir. 
 * Bu operatörlerin yan etkisi (side effect) yoktur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mod operatörünün birinci operandı negatif ise sonuç negatif çıkar. İkinci operandının negatif olmasının bir önemi yoktur.
 * Başka bir deyile mod operatörünün sonucunun işareti birinci operandının işareti ile aynıdıur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldığı en fazla 3 basamaklı int türünden bir sayının basamakları toplamına
 * geri dönen digitsSum isimli metodu NumberUtil sınıfı içerisinde yazınız. Metot aldıgı argümanın en fazla
 * 3 basamaklı olup olmadıgını kontrol etmeyecektir. Basamaklar toplamı pozitif olarak döndürecektir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		DigitsSumTest.run();
	}
}

class DigitsSumTest{
	public static void run() {
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d sayısının basamakları toplamı = %d%n", val, NumberUtil.digitsSum(val));
	}
}

class NumberUtil{
	public static int digitsSum(int val) {
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10;
		c = val % 10;
		
		return Math.abs(a + b + c);
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerinin tersini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = -a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * işaret + aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = +a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - operaörünün seviyesinde bulunan operaötlerin sagdan sole (right associative)
 * ele alınmasından dolayı geçerlidir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		int b;
		
		b = a - - - - - - - - - - 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * geçerli ifade
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a =  - - - - - - - - - - 10;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		++a; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		a++; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü prefix kullanımında ürettiği deger yani işleme giren deger arttırılmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = ++a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü postfix kullanımında ürettiği deger yani işleme giren deger arttırılMAmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a++; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		--a; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		a--; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü prefix kullanılmaktadır degeri o an azaltmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = --a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü postfix kullanılmaktadır degeri o an azaltMAmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a--; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + ++a; 
		
		System.out.printf("a = %d%n", a); // 10
		System.out.printf("b = %d%n", b); //21 //22 //20
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 3;
		
		b = a-- + ++a * a; //3 + 3 * 3 = 12
		
		System.out.printf("a = %d%n", a); // 3
		System.out.printf("b = %d%n", b); //12
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + a-- + a; //10 + 9 + 8
		
		System.out.printf("a = %d%n", a); // 8
		System.out.printf("b = %d%n", b); //27
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi
 * alacak şeklilde atomlarına ayırma işlemi yaparak (maximum munch). 
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 11;
		int c;
		
		c = a+++b; //a++ + b 
		
		System.out.printf("a = %d%n", a); 
		System.out.printf("b = %d%n", b); 
		System.out.printf("c = %d%n", c); 
	}
}

	Not: Okunabilirlik/algılanabilirlik açısından tek operandlı operatörleri genel olarak operandına
	bitişik biçimde yazacağız. İki operandlı operatörleri de özel ama önemli operatörler dışında operandları ile operatör
	arasında yalnızca bir tane "space" karakteri olacak şekilde yazacağız
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ ve -- operatörlerinin operandlarının değişken olması gerekir. Aksi durumda error oluşur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = --2;//error
		
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
15.12.2022 Perşembe

/*
 * temel karsılastırma operatorleri 6 tanedir: == , != , <, >, <= , >=
 * bu operatorlerin hepsi iki operandlı ve araek durumundadır.
 * Bu operatörlerin yan etkisi yoktur.
 * Bu operatörlerin ürettiği deger boolean türdendir. 
 * Karşılaştırmanın sonucu dogru ise true, yanlış ise false degerini üretirler.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
			
		
		System.out.printf("%d > %d -> %b%n", a, b, a > b);
		System.out.printf("%d < %d -> %b%n", a, b, a < b);
		System.out.printf("%d >= %d -> %b%n", a, b, a >= b);
		System.out.printf("%d <= %d -> %b%n", a, b, a <= b);
		System.out.printf("%d == %d -> %b%n", a, b, a == b);
		System.out.printf("%d != %d -> %b%n", a, b, a != b);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metot çağırma operatörü
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add(10, 20) * 3;
		
		System.out.printf("result = %d%n", result);
	}
}

class NumberUtil{
	public static int add(int a, int b) 
	{
		return a + b;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java da void bir metot çağrısı "void bir ifade (expression)" olarak ele alınır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.print(10, 20);
	}
}

class NumberUtil{
	public static void print(int a, int b) 
	{
		System.out.printf("%d, %d%n", a, b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * && operatörü
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() && Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return false;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * || operatörü
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * || operatörü
 * || operatörünün kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en çabuk biçimde 
	ulaşacak şekilde çalışmaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * && operatörü
 * && operatörünün kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en çabuk biçimde 
	ulaşacak şekilde çalışmaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return false;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	&& ve || operatörlerinde doğru sonuca en kısa yoldan ulaşabilmek için (yani kısa devre davranışı için) ifadenin
	önce sol tarafı yapılır. Yani bu operatörler işlem sırasında işlem önceliğine uymazlar. Ancak işlem önceliğine
	uyulursa, yani matematiksel olarak (ya da da kabaca kağıt üzerinde) elde edilen sonucu verirler. Şu cümle unutulmamalıdır:
	"&& ve || operatörleri doğru sonuca en kısa yoldan erişirler". Yani derleyici bu operatörler için buna yönelik kod
	üretir. 
	
	Aşağıdaki örnekte && operatörü || operatöründen yüksek öncelikli olmasına karşın önce || işlemi yapılır. Ancak && 
	operatörünün önceliğine göre işlem yapıldığında elde edilen sonuncun aynısı elde edilir 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte işlem sırası ile operatörlerin öncelik sırası aynıdır. Yine en soldaki önce yapılır. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() && Sample.bar() || Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bitsel AND (&) ve bitsel OR (|) operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak değer üretirler. Bu operatörler özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre 
	davranışı olmayan AND ve OR operatörleri olarak düşünülmelidir. Yine bu operatörler için de en soldaki ifade önce
	yapılır. 
	
	Aşağıdaki örnekte && ve || operatörlerleri kullanıldığında elde edilen sonucun aynısı üretilir. Ancak tüm metotlar
	çağrılır
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bitsel AND (&) ve bitsel OR (|) operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak değer üretirler. Bu operatörler özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre 
	davranışı olmayan AND ve OR operatörleri olarak düşünülmelidir. Yine bu operatörler için de en soldaki ifade önce
	yapılır. 
	
	Aşağıdaki örnekte && ve || operatörlerleri kullanıldığında elde edilen sonucun aynısı üretilir. Ancak tüm metotlar
	çağrılır
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;
		
		c = a & b;  //00000000000000000000000000001010
		
		System.out.printf("c = %d%n", c);
		
		c = a | b;  //00000000000000000000000000001011
		
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	& ve | operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerinin işleme sokarlar. 
	Aşağıdaki örnek durumu anlatmak için yazılmıştır. Bitsel operatörlere ilişkin ayrıntılar kullanımları burada
	ele alınmayacaktır 
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;
		
		c = a & b;  //00000000000000000000000000001010
		
		System.out.printf("c = %d%n", c);
		
		c = a | b;  //00000000000000000000000000001011
		
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Mantıksal DEĞİL (logical NOT) operatörünün doğruluk tablosu
	
	op			!op
	T			 F
	F			 T
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		flag = !flag;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Mantıksal DEĞİL (logical NOT) operatörünün doğruluk tablosu
	
	op			!op
	T			 F
	F			 T
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		boolean a = true;		
		
		a = !flag;
		
		System.out.printf("flag = %b%n", flag);
		System.out.printf("a = %b%n", a);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Atama (=) operatörü iki operandlı araek durumunda bir operatördür. Bu operatörün birinci operandı değişken olmalıdır.
	Operatörün şüphesiz yan etkisi vardır. Bu operatör sağdan sola (right associative) öncelikli gruptadır. Atama operatörünün
	ürettiği değer ikinci operandına ilişkin değerdir
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = b = c = 10;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		(a = b) = c = 10;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		a = (b = c) = 10; //error
		

		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte parantezin konması ve konmaması aynı anlamdadır. Çünkü atama operatörü sağdan sola önceliklidir
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		a = b = (c = 10);
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	İşlemli atama operatörlerinin genel biçimi:
	
	 <ifade1> <op>= <ifade2> ifadesinin yaklaşık karşılığı
	 
	 <ifade1> = <ifade1> <op> <ifade2>
	 
	 a += b; //a = a + b;
	 a -= b; //a = a - b;
	 a *= b; //a = a * b;
	 a /= b; //a = a / b;
	 a %= b; //a = a % b;
	 
	 İşlemli atama operatörlerinin ürettiği değer yine birinci operandına atanan değerdir
	 
	 Not: Aslında işlemli atama operatörlerinin genel biçimi tam olarak yukarıdaki gibi değildir. Bu konu
	 ileride ele alınacaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20;
		
		a += b;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	İşlemli atama operatörleri ifadeleri daha basit yazmak için tercih edilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;
		
		a *= b + c; //a = a * (b + c)
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	 örnekte aynı seviyede olan *= ve += operatörleri "right associative" olduğunda işlem sağdan sola doğru
	yapılır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;
		
		a *= b += c; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Java 'da etkisiz ifadeler genel olarak error olusturur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a - 2;
		
		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	ornekte error olusturmaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample{
	public static void foo() {
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Noktalı virgül (;) sonlandırıcıdır (terminator). Genel olarak ifadeleri ayırmak için kullanılır. Java'da noktalı
	virgülden başka sonlandırıcı karakter yoktur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		++a;System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmamış değer olduğundan a sonuçta 10 olur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		a = a++;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmış değer olduğundan a sonuçta 11 olur. Direk ++ uygulandığındaki
	değerle aynıdır. Bu anlamda aşağıdaki kodun etkisi yoktur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		a = ++a;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
	Deyimler (Statements):
	Bir programın çalıştırılan parçalarına denir. Bir program deyimlerin çalıştırılmasıyla çalışır. Java'da deyimler
	5(beş) gruba ayrılır:
	1. Basit deyimler (simple statements)
	2. Bileşik deyimler (compound statements)
	3. Bildirim deyimleri (declaration statements)
	4. Kontrol deyimleri (control statments)
	5. Boş deyim (null/empty statements)

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Basit deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; 
		++a; //basit deyim
		System.out.printf("a = %d%n", a); //basit deyim
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bileşik deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; 
		{//bileşik deyim
			++a; 
			//...
			{
				//..
				System.out.printf("a = %d%n", a); //basit deyim
			}
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bildirim deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;  //bildirim deyim 
		int b; //bildirim deyimi	
		
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Boş deyim. boş deyimin kullanıs durumları ileride ele alnıacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a; ;;;;;;
		//..
		
		;;;;;;;
		;;
		;
		;
		;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminin genel biçimi:
	if (<boolean türden ifade>)
		<deyim>
	[
	else
		<deyim>
	}
	]
	
	if deyimi, varsa else kısmı ile birlikte tek bir deyimdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");	
		} else {
			System.out.println("Tek sayı girdiniz");
		}
		
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminde bileşik deyimi kullanımı
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) { 
			System.out.println("Çift sayı girdiniz");
			val /= 2;
	    }else
			System.out.println("Tek sayı girdiniz");
			val *= 2;
		
		System.out.println("Ali Tekrar yapiyormusun");
		System.out.printf("val = %d%n", val);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	else kısmı olmayan if edyimi
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0)
			System.out.println("Çift sayı girdiniz");
		
		System.out.println("Ali Tekrar yapiyormusun");
		System.out.printf("val = %d%n", val);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	if deyiminin parantezi sonuna yanlışlıkla noktalı virgül konması durumu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0);
			System.out.println("Çift sayı girdiniz");
			val /= 2;
			
		System.out.printf("val = %d%n", val);
		System.out.println("Ali Tekrar yapiyormusun");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte else bir if deyimine ait olmadığından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val % 2 == 0)
			;
			val /= 2;
		else
			val *= 2; 
			
		
		System.out.printf("val = %d%n", val);
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val > 0)
			if(val % 2 == 0)
				System.out.println("Pozitif ve çift bir sayı girdiniz : ");
			else
				System.out.println("Pozitif bir sayi girmelisiniz");
			
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val > 0)
			if(val % 2 == 0)
				System.out.println("Pozitif ve çift bir sayı girdiniz : ");
			else
				System.out.println("teksayi sayı girdiniz");
		else
			System.out.println("Pozitif bir sayi girmelisiniz");
		
		System.out.println("Ali Tekrar yapiyormusun");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminin parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(val % 2 == 0);
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)//if(even == true)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	if deyiminin parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(val % 2 == 0);
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)//if(even != false)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte isEven metodunda if deyiminin else kısmına gerek yoktur. Çünkü akış return deyimine geldiğinde
	metot sonlanır yani isEven içerisinde bir sonraki deyime geçmez. Bu durumda else yazılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		if(a % 2 == 0)
			return true;
		else 
			return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kodun iyi  teknikte yazılmış hali
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		if(a % 2 == 0)
			return true;
		 
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kodun daha iyi  teknikte yazılmış hali
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(NumberUtil.isEven(val))
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(!NumberUtil.isEven(val))
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte isOdd metodu için kod tekrarı yapılmadığına yani işi yapan başka bir metodun çağrıldığına dikkat ediniz.
	Yazılım geliştirmede "ZORUNLU OLMADIKÇA" kod tekrarı yapılmaması gerekir. Bu kavrama "DO NOT REPEAT YOURSELF" de denir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.isEven(val));
		System.out.println(NumberUtil.isOdd(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
	public static boolean isOdd(int a) 
	{
		return !isEven(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki *** ile belirtilen if deyimi else kısmı ile birlikte tek bir deyimdir. Bu if deyiminin else kısmında 
	başka bir if deyimi vardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else
			if(val == 0)
				System.out.println("Sıfır sayısını girdiniz");
			else
				System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
	Yukarıdaki örnek daha okunabilir/algılanabilir olarak aşağıdaki gibi yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki koşullar ayrık koşullardır. Bu durumda kod doğu çalışsa bile aşağıdaki gibi yazılmamalıdır. else-if
	biçiminde yazılması (yukarıdaki gibi) hem okunabilirdir hem de gereksiz yere kontrol edilmesi gibi durumlar oluşmaz.
	Aşağıdaki örnek şüphesiz kolay anlaşılırdır. Ancak büyük projelerde koşulların ayrık olup olmadığının anlaşılması
	aşağıdaki gibi bir yazımda zaman alabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		if(val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kod böyle yazılmalıydı if lerin birbiri ile ilişkili oldugundan 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else if(val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki koşullar ayrık oldugunda örnek özelinde else-if biçiminde kullanılması yanlış olur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 6)
			System.out.printf("val > 6%n");
		if(val > 11)
			System.out.println("val > 11%n");
		if(val > 21)
			System.out.printf("val > 21%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
20.12.2022 Salı

/*
 * Sınıf çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerin bulup ekrana yazdıran programı yazınız.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci katsayiyi giriniz : ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci katsayiyi giriniz : ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üçüncü katsayiyi giriniz : ");
		double c = Double.parseDouble(kb.nextLine());
			
		EquationSolver.printRoots(a, b,c);
		
	}
}

class EquationSolver{
	
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double x1, x2;
		double sqrtDelta = Math.sqrt(delta);
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
	
		System.out.printf("x1 = %f,  x2 = %f%n", x1, x2);
	}
	
	public static void doWorkForSameRoots(double a, double b)
	{
		double x = -b / (2 * a);
		System.out.printf("x1 = x2 = %f%n", x);
	}
	
	public static double getDelta(double a, double b, double c)
	{
		return b* b - 4 * a * c;
	}
	
	public static void printRoots(double a, double b, double c)	
	{
		double delta = getDelta(a, b, c);
		
		if(delta > 0)
			doWorkForDifferentRoots(delta, a, b);
		else if (delta == 0)
			doWorkForSameRoots(a, b);
		else 
			System.out.println("Gercek kök yok");
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Sınıf çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerin bulup ekrana yazdıran programı yazınız.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci katsayiyi giriniz : ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci katsayiyi giriniz : ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üçüncü katsayiyi giriniz : ");
		double c = Double.parseDouble(kb.nextLine());
			
		EquationSolver.printRoots(a, b,c);
		
	}
}

class EquationSolver{
	
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double x1, x2;
		double sqrtDelta = Math.sqrt(delta);
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
	
		System.out.printf("x1 = %f,  x2 = %f%n", x1, x2);
	}
	
	public static double getDelta(double a, double b, double c)
	{
		return b* b - 4 * a * c;
	}
	
	public static void printRoots(double a, double b, double c)	
	{
		double delta = getDelta(a, b, c);
		
		if(delta >= 0)
			doWorkForDifferentRoots(delta, a, b);
		else 
			System.out.println("Gercek kök yok");
	}
	
}



-----------------------------------------------------------
-----------------------------------------------------------
Döngü deyimleri (loop statements)

Bir işin yenilenmeli olarak yapılması için kullanılan kontrol deyimlerine denir. 
Java'da göngü deyimleri şunlardır:

1. while döngü deyimleri
	- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
	- Kontrolün sonra yapıldığı while döngü deyimi (do-while döngüsü)
2. for göngü deyimi
3. for-each döngü deyimi (enhanced for loop, range based loop)

Not: Bu aşamadan itibaren tüm konular içerisinde "while döngü deyimi" ya da "while döngüsü" dendiğinde
	"kontrolün başta yapıldığı while döngü deyimi" anlaşılmalıdır. "Kontrolün sonra yapıldığı while döngü deyimi" için 
	kısaca "do-while döngüsü" ya da "do-while döngü deyimi" diyeceğiz 
-----------------------------------------------------------
-----------------------------------------------------------

Kontrolün başta yapıldığı while döngü deyiminin genel biçimi:

	while(<koşu ifadesi>)
		<deyim>
		
	koşuş ifadesi boolean türden olmalıdır. Bu döngü ifadesi true oldugu sürece yenilenir. 
	Akış while döngüsüne geldiğinde koşul kontrolü yapılır ve koşul gerçekleşmezse (yani tur degeri üretilmezse) döngüye girilmez.

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i++);
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsü ile n-kez dönen kalıp
	 n = 3 olsun 
	 Döngünün içerisindeyken her adımda basılan n değerleri	: 2, 1, 0
	 Sayaç													: 1, 2, 3
	 Döngü sonrası n										: -1	
	 
	 Buu kalıpta n-nin döngüden sonra değerinin değiştiğine, dolayısıyla döngü öncesindeki değeri kaybettiğimize dikkat 
	 ediniz. Bu kalıp kullanılacaksa ve döngüden sonra n-nin eki değerine ihtiyaç olacaksa döngü öncesinde n değeri
	 saklanmalıdır. Bu kalıbın zorunlu olarak kullanılacağı bir durum yoktur. Ancak baz programcılar bu kalıbı kullanabilirler.
	 Böyle bir kodun anlaşılması açısında döngü kalıbı bilinmelidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
	
		while (n-- > 0) {
			System.out.printf("%d ", n);
		}
		
		System.out.printf("%ni = %d%n", n);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp atanan değerin kontrolüne
	 ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi bir kod
	 yazılabilir. 
	 
	 Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. while döngüsünün parantezi
	 içerisinde atama işleminin önceliklendirildiğine dikkat ediniz.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			sum += val;
		
		System.out.printf("Toplam : = %d%n", sum);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp atanan değerin kontrolüne
	 ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi bir kod
	 yazılabilir. 
	 
	 Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. while döngüsünün parantezi
	 içerisinde atama işleminin önceliklendirildiğine dikkat ediniz.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int sum = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) { 
			sum += val;
			System.out.print("Bir sayi girinz, taki sıfır girene kadar: ");
		}
			
		
		System.out.printf("Toplam : = %d%n", sum);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayıların pozitif ve negatif olanlarının ayrı ayrı toplamını
 *   bulan programı yazınız. Programda hiç negatif veya pozitif sayı girilmemişse uygun mesajlar verilmelidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindPosNegSumApp.run();
	}
}

class FindPosNegSumApp {
	public static void printResult(int posSum, int negSum) 
	{
		if(posSum != 0)
			System.out.printf("Pozitif sayıların toplamı : %d%n", posSum);
		else
			System.out.println("Hiç pozitif sayi girmediniz!!!");
		
		if(negSum != 0)
			System.out.printf("Negatif sayıların toplamı : %d%n", negSum);
		else
			System.out.println("Hiç negatif sayi girmediniz!!!");
	}
	
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int posSum = 0, negSum = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			if(val > 0)
				posSum += val;
			else
				negSum += val;
			
		printResult(posSum, negSum);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Yukarıdaki pozitif ve negatif sayıların kaçar tane girildiğini bulan koda çevir.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		FindPosNegSumApp.run();
	}
}

class FindPosNegSumApp {
	public static void printResult(int posSum, int negSum, int posCount, int negCount) 
	{
		if(posSum != 0)
			System.out.printf("%d tane Pozitif sayıların toplamı : %d%n",posCount, posSum);
		else
			System.out.println("Hiç pozitif sayi girmediniz!!!");
		
		if(negSum != 0)
			System.out.printf("%d tane Negatif sayıların toplamı : %d%n",negCount, negSum);
		else
			System.out.println("Hiç negatif sayi girmediniz!!!");
	}
	
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int posSum = 0, negSum = 0;
		int posCount = 0, negCount = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			if(val > 0) {
				posSum += val;
				++posCount;
			} else {
				negSum += val;
				negCount++;
			}
		printResult(posSum, negSum, posCount, negCount);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli
 *   metodu NumberUtil isimli sınıf içerisinde yazınız ve alttaki kod ile test ediniz.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));
			System.out.println("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		if(val == 0) // !val ile aynı şet val == 0
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;
		}
		
		return count;
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamını döndüren sumDigits isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz. Metot negatif sayılar için basamakları 
	 toplamını pozitif olarak döndürecektir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		SumDigitsTest.run();
	}
}

class SumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının basamakları toplamı:%d%n", val, NumberUtil.sumDigits(val));
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamakları toplamı:%d%n", NumberUtil.sumDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int sumDigits(int val) 
	{
		int sum = 0;
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}
		
		return sum;
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersini döndüren reversed isimli metodu NumberUtil
	 sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 
	 123 -> 3 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		ReversedTest.run();
	}
}

class ReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının tersi:%d%n", val, NumberUtil.reversed(val));
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının tersi:%d%n", NumberUtil.reversed(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int reversed(int val) 
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngü deyiminde yanlışlıkla noktalı virgül kullanılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0);
			sum += val;
		
		System.out.printf("Toplam : %d%n", sum);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Kontrolün sonra yapıldığı while döngü deyiminin (do-while döngüsü) genel biçimi:
	 
	 do
	 	<deyim>
	 while (<boolean türden ifade>);
	 
	 Akış do-while döngüsüne geldiğinde koşul kontrolü yapılmaz. İlk adım çalıştırıldıktan sonra kontrol yapılmaya başlar.
	 Yani bu döngü deyiminin en az bir kez çalıştırılacağı garanti altındadır. while döngü deyimi kadar sık kullanılmasa da
	 okunabilirliği/algılanabilirliği artırmak ve algoritmanın sadeleştirilmesi için tercih edilebilir. Ancak bu döngü
	 deyimi gereksiz yere kullanıldığında okunabilirliği/algılanabilirliği azaltır. Buna dikkat edilmelidir

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < val);
		
		System.out.printf("%nDöngü sonrası :i =  %d%n", i);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
27.12.2022 Salı  11.Ders


/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 Not: İleride daha iyisi yazılacaktır

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
			System.out.println("Bir sayi giriniz : ");
		}
		System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(0));
		
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   do- while döngüsünün deyimi içerisinde bildirilen bir değişken faaliyet alanı (scope)
 *   kuralları gereği koşul ifadesi içerisinde kullanılamaz

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		do {
			System.out.print("Bir sayı giriniz:");	
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   yukarıdaki problemi bu şekilde çözümleriz

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		do {
			System.out.print("Bir sayı giriniz:");	
			val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *    Sonsuz döngü (inifinite loop): Koşul ifadesinden dolayı sonlanmayan döngülere denir. Bu durumda hiç sonlanmayan 
	 bir döngü de sonsuz döngüdür. Tersine sonsuz döngü olarak tasarlanmış bir döngü sonlanabilecek şekilde yazılabilir

 */

/*
 * while döngüsü ile sonsuz döngü aşağaıdaki gibi oluşturulabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		while (true) {
			//..
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 Not: İleride daha iyisi yazılacaktır


	Örnekteki test kodunu sonsuz döngüye çevirelim? nasıl yaparız?
	
	Run metodunu 0 geldiğinde return deyimi ile sonlandırırsak sonsuz döngüden çıkarız
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Bir sayi giriniz : ");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
			
			if(val == 0) {
				System.out.println("0 degeri geldi, run metodu sonlandırıldı");
				return;
			}
		}	
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	 for döngü deyiminin genel biçimi:
	 for ([1.kısım]; [2.kısım]; [3.kısım])
	 	<deyim>
	 	
	 1.kısım: Akış for döngü deyimine geldiğinde bir kez yapılacak kısımdır 
	 
	 2.kısım: for döngü deyiminin koşul ifadesine ilişkin kısımdır. Buraya yazılacak ifadenin boolean türden olması gerekir.
	 Bu ifade true olduğu sürece döngü yinelenir. Akış for döngü deyimine geldiğinde 1.kısım yapıldıktan sonra kontrol 
	 yapılır
	 
	 3.kısım: Döngünün bir adımı tamamlandığında bir sonraki adıma geçmek için yapılacak kontrolden hemen önce yapılır
----------------------------------------------------------------------------------------------------------------------*/

/*
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi tersten 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = n - 1; i >= 0; --i) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = 0; i < n; i += 2) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for döngü deyiminin birinci kısmında bildirilen değişken for döngü deyimi boyunca görülebilirdir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.printf("%d ", i); //error
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Aşağıdaki for döngü deyiminde "aynı faaliyet alanı içerisinde aynı isimde birden fazla yerel değişken bildirimi
	 geçersizdir" kuralı dolayısıyla error oluşur 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { //error
			System.out.printf("%d ", i);
		}
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Aşağıdaki for döngü deyimi "farklı faaliyet alanları içerisinde aynı isimde yerel değişenler bildirilebilir" kuralı
	 dolayısıyla geçerlidir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Döngü değişkenin değeri döngüden sonra kullanılmayacaksa döngü değişkeniş bildiriminin birinci kısımda yapılması
	 daha iyi bir tekniktir. Bu durumda döngü değişkeninin döngüden önce bildirilmesi döngüden sonra değişkenin değerinin 
	 kullanıldığı algısını oluşturur. Yani okunabilirlik/algılabilirlik artırılmış olur 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte error oluşmaz  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;
		
		for (i = n - 1; i > 0; --i); 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte neden error oluşur?  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i); 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı (dizi uyumlu)  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı (dizi uyumlu)  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = n - 1; i >= 0; --i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1; i <= n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1, k = 20; i <= n && k >= 0; ++i, --k) 
			System.out.printf("{i : %d, k : %d}%n", i, k);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		int i = 0;
		
		for (System.out.println("Birinci kısım"); i < 5; System.out.println("Üçüncü kısım"), ++i) 
				System.out.println("Deyim");
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *   for döngüsünün birinci kısmında değişken bildirimi yapılmışsa başka bir ifade yazılamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{		
		for (System.out.println("Birinci kısım"), int i = 0; i < 5; System.out.println("Üçüncü kısım"), ++i) 
				System.out.println("Deyim");
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *  for döngüsünün birinci kısmında bildirilen değişkenler aynı türden olmalıdır  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{		
		for (int i = 0, double k = 3.4; i < 5 && k > 3.8; ++i, k -= 0.03) 
				System.out.printf("{i : %d, k : %f}%n", i, k);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Aşağıdaki döngü deyimini inceleyiniz 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		int i;
		double k;
		
		for (i = 0, k = 3.4; i < 5 && k > 3.8; ++i, k -= 0.03) 
				System.out.printf("{i : %d, k : %f}%n", i, k);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünün gücü: Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		int val;
		
		for(System.out.println("Sayıları girmeye başlayınız:"), System.out.print("Bir sayi giriniz:");
				(val = Integer.parseInt(kb.nextLine())) != 0; sum += val, System.out.print("Bir sayı giriniz: "))
			;
		
		System.out.printf("Toplam: %d%n", sum);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Hiç sonlanmayacak sanılan ancak öyle olmayan bir döngü örneği. Örnekte i değeri azalarak  -2147483648 değerine yani
	int türünün en küçüçük değeirne geldiğinde artık bir azaltıldığında 2147483647 değeri elde edilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		int i;

		for(i = 0; i < 10; --i)
			;
		
		System.out.printf("i = %d%n", i);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde birinci kısmın boş bırakılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;

		for(; i < n; ++i)
			System.out.printf("i = %d%n", i);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde üçüncü kısmın boş bırakılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		

		for(int i = 0; i < n;)
			System.out.printf("i = %d%n", i++);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde birinci üçüncü kısmın boş bırakılması durumu while döngü deyimine benzetilebilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;

		for(; i < n;)
			System.out.printf("i = %d%n", i++);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde ikinci kısmın boş bırakılması durumunda sonsuz döngü oluşur. Yani koşul her zaman gerçeklenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for(int i = 0; ;++i)
			System.out.printf("i = %d%n", i);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsü ile sonsuz döngü oluşturmak için okunabilirlik/algılanabilirlik açısından 3 kısmın da boş bırakılması 
	iyi bir tekniktir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		for(;;)
			;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
    Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
					
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
		
			if(val == 0) {
				System.out.println("Ali Tekrarlar nasıl gidiyor?");
				return;
			}
		}		
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}


/**********************************************************************************************
    Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a'nın b-inci kuvvetini döndüren pow isimli
	 metodu NumberUtil sınıfı içerisinde yazınız.
	 Açıklamalar:
	 - Math sınıfının pow metodu kullanılmayacaktır
	 - Metot negatif b değerleri için 1(bir) değerine geri dönecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Taban sayısı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
					
			System.out.print("Üst sayısı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
		
			if(a == 0) {
				System.out.println("Ali Tekrarlar nasıl gidiyor?");
				return;
			}
		}		
	}
}

class NumberUtil{
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for(int i = 0; i < b; i++)
			result *= a;
		
		return result;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153
	 
	 - Kuvvet alma işlemi için yazılmış olan pow metodunu kullanınız
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz	
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = 1; a <= 999999; ++a)
			if (NumberUtil.isArmstrong(a)) 	
					System.out.println(a);
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isArmstrong(int a)
	{
		return a >= 0 && getDigitsPowSum(a) == a;
	}
	
	public static int getDigitsPowSum(int a)
	{
		int n = countDigits(a);
		int total = 0;

		while (a != 0) {
			total += pow(a % 10, n);
			a /= 10;
		}
		
		return total;
	}
	
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for(int i = 0; i < b; i++)
			result *= a;
		
		return result;
		
	}
	
	public static int countDigits(int a) {
		int count = 0;
		
		do {
			++count;
			a /= 10;
			
		}while(a != 0);
			
		return  count;	
	}
	
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 (Yavaş çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = -10; a <= 1000; ++a)
			if (NumberUtil.isPrime(a)) 	
					System.out.printf("%d ", a);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i)
			if(a % i == 0)
				return false;
		
		return true;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 Kural: Bir sayı karekökünden küçük olan asal sayıların hiçbirisine bölünmüyorsa asaldır
	 (Hızlı çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = -10; a <= 1000; ++a)
			if (NumberUtil.isPrime(a)) 	
					System.out.printf("%d ", a);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;

		for(long i = 11; i * i <= a; i += 2)
			if(a % i == 0)
				return false;
		
		return true;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 Kural: Bir sayı karekökünden küçük olan asal sayıların hiçbirisine bölünmüyorsa asaldır
	 (Hızlı çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
				
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;

		int count = 0;
		for(long i = 11; i * i <= a; i += 2) {
			count++;
			if(a % i == 0)
				return false;
			
		}
		
		System.out.printf("isPrime:count = %d%n", count);
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		int count = 0;
		
		for(long i = 2; i <= half; ++i) {
			count++;
			if(a % i == 0)
				return false;
		}
		
		System.out.printf("isPrime:count = %d%n", count);
		return true;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();		
	}
}

class GetPrimeTest{
	public static void run() 
	{
				
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0) {
				return;
			}
			
			System.out.printf("%d. asal sayi: %d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil{
	public static int getPrime(int n) 
	{
		int val = 2;
		
		for(int i = 2, count = 0; count < n; ++i)
			if(isPrime(i)) {
				++count;
				val = i;
			}
		
		return val;
	}
	
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;


		for(long i = 11; i * i <= a; i += 2) {
			if(a % i == 0)
				return false;	
		}
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i) {
			if(a % i == 0)
				return false;
		}
		
		return true;
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();		
	}
}

class GetPrimeTest{
	public static void run() 
	{
				
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0) {
				return;
			}
			
			System.out.printf("%d. asal sayi: %d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil{
	public static int getPrime(int n) 
	{
		int count = 0;
		int val = 2;
		
		for(;;) {
			if(isPrime(val))
				++count;
			
			if(count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;


		for(long i = 11; i * i <= a; i += 2) {
			if(a % i == 0)
				return false;	
		}
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i) {
			if(a % i == 0)
				return false;
		}
		
		return true;
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının faktoriyel değerini döndüren factorial isimli metodu
	 NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 Açıklamalar:
	 - Faktoriyel işlemi aşağıdaki gibidir: 
		 0! = 1
		 1!= 1
		 2! = 1 * 2
		 3! = 1 * 2 * 3
		 
		 ...
		 
		 n! = 1 * 2 * 3 * ... * (n - 1) * n
	 
	 - Negatif sayılar için faktoriyel değeri 1 olarak döndürelecektir	
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		FactorialTest.run();		
	}
}

class FactorialTest {
	public static void run()
	{		
		for (int n = -1; n <= 25; ++n)
			System.out.printf("%d! = %30d%n", n, NumberUtil.factorial(n));
	}
}

class NumberUtil{
	public static int factorial(int n) 
	{
		int result = 1;
		
		for(int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     içiçe döngüler
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int i = 0; i < 5; ++i)
			for(int k = 10; k >= 0; --k)
				System.out.printf("(%d, %d)%n",i ,k);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     	Programcılar bazen tek bir döngü varsa da döngü içerisinde çağrılan metot veya metotlar içerisinde döngü kullanılmışsa
	içiçe döngü olacak şekilde bir kod yazmış olurlar
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int i = 0; i < 5; ++i)
			Util.print(i);
	}
}

class Util{
	public static void print(int i) {
		for(int k = 10; k >= 0; --k)
			System.out.printf("(%d, %d)%n",i ,k);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     	3 basamaklı Armstrong sayılarının iç içe döngü ile bulunması
     	
     	abc -- 1-9  0-9 0-9
     	
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int a = 1; a <= 9; ++a)
			for(int b = 0; b <= 9; ++b)
				for(int c = 0; c <= 9; ++c)
					if(a * a * a + b * b * b + c * c * c == 100 * a + 10 * b + c)
						System.out.printf("%d%d%d%n", a, b, c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------
	break deyimi döngüyü, döngünün koşul ifadesinden bağımsız olarak sonlandırmak (kırmak) için kullanılır. break deyimi
	döngü deyimleri ile kullanılır ve ileride göreceğimiz "switch" deyiminde de kullanılır. Bunlar dışında kullanımı error
	oluşturur.
	
	break deyiminin genel biçimi:
	break [etiket ismi];
     	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	break deyiminin etiketsiz kullanımında akış break deyimine geldiğinde döngü sonlandırılır. Döngüden sonraki koddan
	devam edilir. break hangi döngü içerisinde etiketsiz kullanılmışsa o döngü sonlandırılır. 
	Aşağıdkai örnekte klavyden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. Sıfır girildiğinde break
	deyimi ile döngü sonlandırılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayiları girmeye başlayınız : ");
		
		int sum = 0;
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int a = Integer.parseInt(kb.nextLine());
			
			if(a == 0)
				break;
			
			sum += a;
		}
		System.out.printf("Toplam: %d%n", sum);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());			
			
			if (n <= 0)				
				break;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");	
	}
}

class NumberUtil {
	public static int getPrime(int n)
	{
		int count = 0;
		int val = 2;
		
		for (;;) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long a)
	{
		if (a <= 1)
			return false;
		
		if (a % 2 == 0)
			return a == 2;
		
		if (a % 3 == 0)
			return a == 3;		
		
		if (a % 5 == 0)
			return a == 5;
		
		if (a % 7 == 0)
			return a == 7;

		for (long i = 11; i * i <= a; i += 2)
			if (a % i == 0)
				return false;
		
		return true;		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	break deyimi yalnızca kendi döngüsünü sonlandırır. Aşağıdaki örnekte içteki döngüde bir koşul gerçekleştiğinde 
	 dıştaki döngünün de sonlandırılması flag değişken kullanılarak yapılmıştır. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean breakAllFlag = false;
		
		for(int i = 5; i < 10; ++i) {
			for(int k = 20; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if((i + k) % 6 == 0) {
					breakAllFlag = true;
					break;
				}
			}
			
			if(breakAllFlag)
				break;
		}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak döngü deyiminin başında bir etiket bildirimi
	yapılır. Etiket bildiriminin genel biçimi:
		<etiket ismi>:
	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirirler.
	Yukarıdaki program aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
	
		EXIT_LOOP:
		for(int i = 5; i < 10; ++i) {
			for(int k = 20; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if((i + k) % 6 == 0)
					break EXIT_LOOP;
			}
		}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak döngü deyiminin başında bir etiket bildirimi
	yapılır. Etiket bildiriminin genel biçimi:
		<etiket ismi>:
	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirirler.
	Yukarıdaki program aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
	
		EXIT_LOOP:
		for(int i = 5; i < 100; ++i) 
			EXIT_INNER_LOOP:
			for(int j = 0; j < 100; ++j)
				for(int k = 20; k >= 0; --k) {
					System.out.printf("(%d, %d, %d)%n", i, j, k);
					
					if((i + j + k) % 10 == 0)
						break;
					
					if((i + j + k) % 6 == 0)
						break EXIT_INNER_LOOP;
					
					if((i + j + k) % 11 == 0)
						break EXIT_LOOP;
					
				}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	continue deyimi döngüyü değil döngünün o anki adımını sonlandırmak için kullanılır. continue deyiminin de etiketli
	biçimi vardır. Ancak yapısal programlama ve nesne yönelimli programlama tekniği açısından kullanımı tavsiye edilmez.
	continue deyiminin etiketsiz biçimi break deyimi kadar sık kullanılmasa da bazı durumlarda okunabilirlik/algılanabilirlik
	açısından tercih edilebilir. continue yalnızca döngü deyimlerinde kullanılabilir.
	
	Aşağıdaki örnekte 1 ile klavyeden girilen sayı arasındaki çift sayılar continue deyimi kullanılarak ekrana bastırılmıştır. 
	Şüphesiz daha kolay yazılabilir. Sadece continue deyiminin çalışma prensibinin anlaşılabilmesi için bu şekilde 
	yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for(int i = 1; i <= n; ++i) {
			if(i % 2 != 0)
				continue;
			
			System.out.printf("%d ", i);
		}
		
		System.out.println("\nÇok çalışalım Erken uyuyalım Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulması iskeleti yazıldı
	(ileri daha iyisi yazılacak)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(option < 1 || option > 5) {
				System.out.println("\"Geçersiz seçenek\"");
				continue;
			}
			
			if(option == 5)
				break;
			
			doWorkFor(option);
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{
		if(option == 1)
			doWorkForInsert();
		else if(option == 2)
			doWorkForUpdate();
		else if(option == 3)
			doWorkForDelete();
		else
			doWorkForList();
		
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulması iskeleti yazıldı
	(ileri daha iyisi yazılacak)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(1 <= option && option <= 5) {
				if(option == 5)
					break;
				
				doWorkFor(option);
			} 
			else
				System.out.println("\"Geçersiz seçenek\"");
		}
		System.out.println("Teşekkürler");
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{
		if(option == 1)
			doWorkForInsert();
		else if(option == 2)
			doWorkForUpdate();
		else if(option == 3)
			doWorkForDelete();
		else
			doWorkForList();
		
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı n sayısı için n-inci Fibonacci sayısını döndüren fibonacciNumber isimli 
	metodu NumberUtil sınıfı içerisinde ve aşağıdaki kod ile test ediniz
	Açıklama:
		- Fibonnaci sayıları
			0 1 1 2 3 5 8 13 21 34 ...
		- Metot pozitif olmayan n değerleri için kontrol yapmayacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FibonacciNumberTest.run();
	}
}

class FibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n < 1)
				break;
			
			System.out.printf("%d. Fibonacci sayısı:%d%n", n, NumberUtil.fibonacciNumber(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int fibonacciNumber(int n) 
	{
		if(n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = 0;
		
		for(int i = 2; i < n; ++i) {
			val = prev1 + prev2;
			prev2 = prev1;
			prev1 = val;
		}
		
		return val;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayıdan büyük ilk Fibonacci sayısına geri dönen nextFibonacciNumber
	isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		NextFibonacciNumberTest.run();
	}
}

class NextFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val < -999)
				break;
			
			System.out.printf("%d. sayısından büyük ilk Fibonacci sayısı:%d%n", val, NumberUtil.nextFibonacciNumber(val));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nextFibonacciNumber(int val) 
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0, next;
		
		for (;;) {
			next = prev1 + prev2;
			
			if (next > val)
				return next;
			
			prev2 = prev1;
			prev1 = next;
		}
	}	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin genel biçimi:
	switch (<ifade>) {
		case <sabit ifadesi>:
			<deyim>
		case <sabit ifadesi>:
			<deyim>
			
		...
		
		[
		default:
			<deyim>
		]			
	}
	
	Bu deyimde parantez içerisindeki ifade temel türler için tamsayı türlerinden biri veya char türünden olabilir.
	Temel türler dışında String veya enum türlerinden de olabilir. Bu türler ileride ele alınacaktır. switch 
	deyiminin default kısmı zorunlu değildir.
	
	
	Anahrtat Notlar: switch deyimi Java 12'den itibaren ifade (expression) olarak da kullanılabilmektedir. Bu tarz 
	deyimlere/ifadelere "ifadesel deyim (expression statement)". switch'in ifade olarak kullanılmasına yönelik sentaks
	ve semantik eklentiler yapılmıştır. İleride ele alınacaktır.  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki switch deyiminin if deyimi karşılığı:
	
	if (postalCode == 414100)
		System.out.println("Gebze");
	else if (postalCode ==  37100)
		System.out.println("Kastamonu Merkez");
	else
		System.out.println("Geçersiz posta kodu");
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

04.01.2023 - Çarşamba - 13.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde default kısım olmak zorunda değildir. Aşağıdaki switch deyiminin if deyimi karşılığı:
	
	if (postalCode == 414100)
		System.out.println("Gebze");
	else if (postalCode ==  37100)
		System.out.println("Kastamonu Merkez");

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;

		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde default bölümün yerinin önemi yoktur. Şüphesiz sona koymak iyi bir tekniktir	

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: switch deyimin bölümlerinden (case ve default) çok fazla işlem yapılması okunabilirlik/algılanabilirlik
	açısından iyi bir teknik değildir. Bu durumda metot yazıp ilgili bölümlerde çağırmak gerekir. Bunun için net bir sınır
	olmasa da 3-4 satırı geçen kodların yazılmaması gerekir 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde case bölümlerine ilişkin ifadeler sabit ifadesi olmalıdır 

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		int code = 37100;
		
		switch (postalCode) {

		case 414100:
			System.out.println("Gebze");
			break;
		case code: //sentaks hatası
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde aynı değere sahip birden fazla case bölümü geçersizdir  
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		
		switch (postalCode) {

		case 414100:
			System.out.println("Gebze");
			break;
		case 37100: //error
			System.out.println("Kastamonu Merkez");
			break;
		case 37100: //error
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde parantez içerisindeki ifade ve case bölümlerine ilişkin sabitlerin temel türler için tamsayı 
	türlerinden biri veya char türünden olabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		double postalCode = Double.parseDouble(kb.nextLine());
		
		
		switch (postalCode) { //error
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminde parantez içerisindeki ifade ve case bölümlerine ilişkin sabitlerin temel türler için tamsayı 
	türlerinden biri veya char türünden olabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		double postalCode = Double.parseDouble(kb.nextLine());
		
		switch (postalCode) { //error
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin aşağı düşme (fall through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülüncüye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Başka engelleyici deyimler de olabilir. Aşağıdaki kodu inceleyiniz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) { 
		case 41410:
			System.out.println("Gebze");
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
			break;
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin aşağı düşme (fall through) özelliği vardır. Bir case bölümü veya default bölüm yakalandığında
	aşağıya doğru engelleyen herhangi bir deyim görülüncüye kadar her deyim çalıştırılır. break deyimi switch deyimini
	sonlandırmak için kullanılır. Başka engelleyici deyimler de olabilir. Aşağıdaki kodu inceleyiniz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) { 
		default:
			System.out.println("Geçersiz posta kodu");
		case 41410:
			System.out.println("Gebze");
		case 37100: 
			System.out.println("Kastamonu Merkez");
			break;

		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch deyiminin aşağı düşme özelliğinden yararlanılmıştır. Aşağıdaki örnekteki 212 ve 216 kodları
	için yapılışın daha kısa bir yönetimi yoktur 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int code = Integer.parseInt(kb.nextLine());
		
		switch (code) { 
		case 212:
		case 216:
			System.out.println("İstanbul");
			break;
		case 312: 
			System.out.println("Ankara");
			break;
		case 284: 
			System.out.println("Edirne");
			break;
		default:
			System.out.println("Geçersiz telefon kodu");
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch deyiminin aşağı düşme özelliğinden yararlanılmıştır. Aşağıdaki örnekteki 212 ve 216 kodları
	için yapılışın daha kısa bir yönetimi yoktur 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int code = Integer.parseInt(kb.nextLine());
		
		switch (code) { 
		case 212:
			System.out.println("Avrupa");
		case 216:
			System.out.println("İstanbul");
			break;
		case 312: 
			System.out.println("Ankara");
			break;
		case 284: 
			System.out.println("Edirne");
			break;
		default:
			System.out.println("Geçersiz telefon kodu");
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulamasının iskeleti
	(ileride daha iyisi yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(1 <= option && option <= 5) {
				if(option == 5)
					break;
				
				doWorkFor(option);
			} 
			else
				System.out.println("\"Geçersiz seçenek\"");
		}
		System.out.println("Teşekkürler");
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{		
		switch (option) {
		case 1:
			doWorkForInsert();
			break;
		case 2:
			doWorkForUpdate();
			break;
		case 3: 
			doWorkForDelete();
			break;
		case 4:
			doWorkForList();
			break;
		default:
			System.out.println("\"Geçersiz seçenek\"");
		}
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Hangi metot içerisinde olursak olalım programı sonlandırmak için System sınıfının exit isimli metodu kullanılabilir.
	Bu metot parametre olarak int türden ismine "çıkış kodu (exit code)" denilen ve JVM ve oradan da işletim sistemine 
	iletilen bir değer alır. Bu değerin çoğu zama n önemi olmaz. Bazı durumlarda okunabilirliği artırmak için başarı veya
	başarısızlığa yönelik belirlenen değerler argüman olarak verilir. main normal sonlandığında JVM ve oradan da işletim
	sistemine 0 (sıfır) çıkış kodu iletilir. Çıkış kodunun nerede kullanılacağı burada ele alınmayacaktır.
	 
	Aşağıdaki örnekte geçersiz giriş durumunda program sonlandırılmıştır. Örnek exit metodunu göstermek amaçlı bu şekilde
	yazılmıştır  
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		SqrtApp.run();
	}
}

class SqrtApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		double val = Double.parseDouble(kb.nextLine());
		
		if(val < 0) {
			System.out.println("Geçersiz giriş");
			System.exit(1);
		}
		
		System.out.printf("sqrt(%f) = %f%n", val, Math.sqrt(val));
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulamasının iskeleti
	(ileride daha iyisi yazılacaktır)  
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();	
			doWorkFor(Integer.parseInt(kb.nextLine()));
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{		
		switch (option) {
		case 1:
			doWorkForInsert();
			break;
		case 2:
			doWorkForUpdate();
			break;
		case 3: 
			doWorkForDelete();
			break;
		case 4:
			doWorkForList();
			break;
		case 5:
			doWorkForQuit();
		default:
			System.out.println("\"Geçersiz seçenek\"");
		}
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForQuit()
	{
		System.out.println("---------------------------------");
		System.out.println("Teşekkürler");
		System.out.println("\"Tekrar Sizleri Mekanımızda Görmek İsteriz\"");
		System.out.println("---------------------------------");
		System.exit(0);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden yıl değerinin artık yıl (leap year) olup olmadığını test eden
	isLeapYear isimli metodu yazınız ve aşağıdaki kod ile test ediniz
		
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		IsLeapYearTest.run();
	}
}

class IsLeapYearTest{
	public static void run() 
	{
		for(int y = 1900; y <= 2023; ++y)
			if(DateUtil.isLeapYear(y))
				System.out.println(y);
	}
}


class DateUtil{
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin geçerli olup olmadığını
	test eden isValidDate isimli metodu yazınız ve aşağıdaki kod ile test ediniz
	(İleride daha iyisi yazılacaktır)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		IsValidDateTest.run();
	}
}

class IsValidDateTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz : ");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if(day == 0)
				break;
			
			if(DateUtil.isValidDate(day, month, year))
				System.out.printf("%02d/%02d/%04d tarihi geçerlidir%n", day, month, year);
			else
				System.out.println("Geçersiz tarih");
			
		}
	}
}

class DateUtil{
	public static boolean isValidDate(int day, int month, int year)
	{
		 return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days = 31;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if(isLeapYear(year))
				++days;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin yılın kaçıncı günü 
	olduğunu döndüren getDayOfYear metodunu yazınız ve aşağıdaki kod ile test ediniz
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Yılın kaçıncı günü olduğuna ilişkin algoritma için aşağıdaki örneklerini inceleyiniz:
			01.03.2020 -> 1 + 29 + 31 = 61
			01.03.2022 -> 1 + 28 + 31 = 60
			31.12.2020 -> 31 + 30 + 31 + ... + 29 + 31 = 366
			31.12.2022 -> 31 + 30 + 31 + ... + 28 + 31 = 365
			
			- İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz : ");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if(day == 0)
				break;
			
			int dayOfYear = DateUtil.getDayOfYear(day, month, year);
			
			if(dayOfYear != -1)
				System.out.printf("%02d/%02d/%04d tarihi yılın %d. günüdür%n", day, month, year, dayOfYear);
			else
				System.out.println("Geçersiz tarih");
			
		}
	}
}

class DateUtil{
	
	public static int getDayOfYear(int day, int month, int year) 
	{
		if(!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if(isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;
		}
		
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		 return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if(isLeapYear(year))
				++days;
		default:
			days = 31;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden 
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir
		
		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte 
				
		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır
		
		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetDayOfYearTest.run();
	}
}

class GetDayOfYearTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz : ");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if(day == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);
		}
	}
}

class DateUtil{
	public static void printDateTR(int day, int month, int year) 
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		if(dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		
		switch (dayOfWeek) {
		case 0:
			System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
			break;
		case 1:
			System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
			break;
		case 2:
			System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);
			break;
		case 3:
			System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);
			break;
		case 4:
			System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
			break;
		case 5:
			System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);
			break;
		case 6:
			System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);
			break;
		}
		
		if(isWeekend(day, month, year))
			System.out.println("Bugün haftasonu....");
		else
			System.out.println("Bugün haftaiçi....");
	}
	
	public static int getDayOfWeek(int day, int month, int year) 
	{
		int totalDays;
		
		if(year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;
		
		for(int y = 1900; y < year; ++y) {
			totalDays += 365;
			if(isLeapYear(year))
				++totalDays;
		}
		
		return totalDays % 7;
	}
	
	public static boolean isWeekend(int day, int month, int year) 
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year) 
	{
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfYear(int day, int month, int year) 
	{
		if(!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if(isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;
		}
		
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{
		 return 1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		switch (month) {
		case 4:
		case 6:
		case 9:
		case 11:
			days = 30;
			break;
		case 2:
			days = 28;
			if(isLeapYear(year))
				++days;
		default:
			days = 31;
		}
		
		return days;
	}
	
	public static boolean isLeapYear(int year) 
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Java 12 ile birlite "preview" olarak "switch expression" dile dahil edilmiştir. Bu durumda switch deyimi artık 
	ifade biçiminde de kullanılacak şekilde sentaks ve samantik olarak geliştirilmiştir. switch deyiminin bu şekilde 
	kullanımı "switch expression statement" olarak da adlandırılabilir. Yani kabaca switch expression semantiği switch 
	statement biçiminde de kullanılabilir. Java dünyasında Java 8, Java 11 ve Java 17 LTS (Long Term Support) olarak
	kullanıldığından switch expression henüz çok yaygınlaşmamıştır. Çünkü halen en çok kullanılan sürümler Java 8 ve 
	Java 11'dir. Java'nın LTS dışında kalan ara sürümlerinin desteği daha çabuk bittiğinden ticari uygulamalarda pek
	kullanılmazlar. Üstelik şu anki durumda Android sistemlerinde Java 17 kullanımı oldukça kısıtlıdır. Ağırlıklı olarak
	Java 8 ve Java 11 kullanılmaktadır  
	
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
Aşağıdaki örnekte switch expression, statement biçiminde kullanılmıştır. switch statement karşılığı:

switch (postalCode) {
case 34387:
	System.out.println("Mecidiyeköy");
	break;
case 67100:
	System.out.println("Zonguldak Bahçelievler");
	break;
default:
	System.out.println("Geçersiz posta kodu");
}

Dikkat edilirse switch expression için aşağı düşme özelliği yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
public static void main(String [] args)
{		
	java.util.Scanner kb = new java.util.Scanner(System.in);		
	
	for (;;) {
		System.out.print("Posta kodunu giriniz:");
		int postalCode = Integer.parseInt(kb.nextLine());
		
		if (postalCode <= 0)
			break;
		
		switch (postalCode) {
		case 34387 -> System.out.println("Mecidiyeköy");			
		case 67100 -> System.out.println("Zonguldak Bahçelievler");
		default -> System.out.println("Geçersiz posta kodu");
		}
	}		
	
	System.out.println("Tekrar yapıyor musunuz?");
	
}
}



/*----------------------------------------------------------------------------------------------------------------------	 
Aşağıdaki örnekte switch expression'ın değeri bir değişkene atanmıştır. Eşdeğeri aşağıdaki gibidir:
	
	switch (code) {
	case 212:
	case 216:
		plate = 34;
		break;
	case 232:
		plate = 35;
		break;
	case 372:
		plate = 67;
		break;
	default:
		plate = -1;
	}
	
	Dikkat edilirse switch expression için aşağı düşme özelliği yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
public static void main(String [] args)
{		
	java.util.Scanner kb = new java.util.Scanner(System.in);		

	for (;;) {
		System.out.print("Posta kodunu giriniz:");
		int code = Integer.parseInt(kb.nextLine());
		
		if (code <= 0)
			break;
		
		int plate = switch (code) {
				case 212, 216 ->  34;
				case 232 -> 35;
				case 372 -> 67;
				default -> -1;			
		};			
				
		if (plate != -1)
			System.out.printf("Plaka:%d%n", plate);
		else
			System.out.println("Geçersiz plaka");
	}			
	
	System.out.println("Tekrar yapıyor musunuz?");
	
}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression'ın değeri metoda argüman olarak geçilmiştir	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;		
			
					
			Util.doWorkForPlate(
					switch (code) {
						case 212, 216 ->  34;
						case 232 -> 35;
						case 372 -> 67;
						default -> -1;			
					}			
			);
		}
		
	}
}

class Util {
	public static void doWorkForPlate(int plate)
	{
		if (plate != -1)
			System.out.printf("Plaka:%d%n", plate);
		else
			System.out.println("Geçersiz plaka");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression, statemnet olarak kullanıldığından default kısmı zorunlu değildir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int postalCode = Integer.parseInt(kb.nextLine());
			
			if (postalCode <= 0)
				break;
			
			switch (postalCode) {
			case 34387 -> System.out.println("Mecidiyeköy");			
			case 67100 -> System.out.println("Zonguldak Bahçelievler");			
			}
		}	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression'ın değeri kullanıldığından default bölüm (default case) zorunludur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = switch (code) { //error
					case 212, 216 ->  34;
					case 232 -> 35;
					case 372 -> 67;								
			};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Klasik switch deyiminin yield anahtar sözcüğ ile değer üretmesi yani expression olarak kullanılması sağlanabilir. Bu da
	yine Java 12 ile dile eklenmiştir. yield kullanıldığında aşağı düşme olmaz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = 
					switch (code) {
					case 212:
					case 216: yield 34;
					case 232: yield 35;
					case 372: yield 67;
					default: yield -1;													
			};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Klasik switch deyiminin yield anahtar sözcüğ ile değer üretmesi yani expression olarak kullanılması sağlanabilir. Bu da
	yine Java 12 ile dile eklenmiştir. yield kullanıldığında aşağı düşme olmaz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = 
					switch (code) {
					case 212:
					case 216:
						System.out.println("İstanbul");
						yield 34;
					case 232: System.out.println("izmir");  yield 35;
					case 372: yield 67;
					default: yield -1;													
					};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte "case 212, 216" bölümü için yield zorunludur. Ayrıca küme parantezi yani, bileşik deyim zorunludur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = 
					switch (code) {
					case 212, 216 -> {
						System.out.println("İstanbul");
						yield 34;
					}
						
					case 232 -> 35;
					case 372 -> 67;
					default -> -1;													
					};			
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte switch expression'ın ürettiği değer metoda geri dönüş değeri olarak verilmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Posta kodunu giriniz:");
			int code = Integer.parseInt(kb.nextLine());
			
			if (code <= 0)
				break;
			
			int plate = Util.getPlateByCode(code);					
					
			if (plate != -1)
				System.out.printf("Plaka:%d%n", plate);
			else
				System.out.println("Geçersiz plaka");
		}		
		
		System.out.println("Tekrar yapıyor musunuz?");		
	}
}

class Util {
	public static int getPlateByCode(int code)
	{
		return switch (code) {
				case 212, 216 -> 34;					
				case 232 -> 35;
				case 372 -> 67;
				default -> -1;													
		};		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden 
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir
		
		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte 
				
		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır
		
		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		GetDayOfWeekTest.run();		
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz?");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);		
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);			
		}
		
		if (isWeekend(day, month, year))
			System.out.println("Bugün kurs var. Tekrar yaptınız mı?");
		else
			System.out.println("Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız");
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;
		
		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;
		
		for (int y = 1900; y < year; ++y) {
			totalDays += 365;
			if (isLeapYear(y))
				++totalDays;
		}
		
		return totalDays % 7;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += 28;
			if (isLeapYear(year))
				++totalDays;
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{		
		return  1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);		
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		days = switch (month) {
			case 4, 6, 9, 11 -> 30;		
			case 2 -> {			
				if (isLeapYear(year))
					yield 29;
				yield 28;
			}
			default -> 31;			
		};
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Menü uygulaması
		
		- İleride daha yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();	
			doWorkFor(Integer.parseInt(kb.nextLine()));
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{		
	
		switch (option) {
		case 1 -> doWorkForInsert();
		case 2 -> doWorkForUpdate();
		case 3 -> doWorkForDelete();
		case 4 -> doWorkForList();
		case 5 -> doWorkForQuit();
		default ->System.out.println("\"Geçersiz seçenek\"");
		}
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForQuit()
	{
		System.out.println("---------------------------------");
		System.out.println("Teşekkürler");
		System.out.println("\"Tekrar Sizleri Mekanımızda Görmek İsteriz\"");
		System.out.println("---------------------------------");
		System.exit(0);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Programcı ne zaman switch expression, ne zaman switch statement kullanmalıdır? Şüphesiz programcı 
	Java 12 öncesinde çalışıyorsa switch expression kullanamaz. Bu durumda programcı zorunlu olmadıkça, okunabilirlik 
	açısından bir sorun da yoksa switch expression tercih etmelidir
----------------------------------------------------------------------------------------------------------------------*/



-----------------------------------------------------------
-----------------------------------------------------------
05.01.2023 Perşembe - 14.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı Türlerin Birbirine Atanması (Tür dönüşümleri-Type Conversions)
	
	
	T1 ve T2 birer tür ismi olmak üzere T1 türünden, T2 türüne yapılan doğrudan atama işlemine T1 türünden T2 türüne
	"doğrudan dönüşüm (implicit conversion)" denir. Atama işlemi de aynı zamanda bir dönüşümdür. Örneğin bu işlem
	
		T1 a;
		T2 b;
		
		b = a;
	
	şeklinde belirtilebilir. Konu içerisinde anlatılcak olan istisna durumlar dışında tüm atama işlemleri için bu tanım
	geçerlidir. İstisna durumlar ayrıca ele alınacaktır
	
	Yukarıdaki atama işleminde T1 türüne "kaynak tür (source type)", T2 türüne de "hedef tür (target type)" denir. Java'da
	kaynak türden hedef türe implicit dönüşümün (atamanın) yapılıp yapılamayacağı derleme zamanında belirlenir. Kaynak türe
	ilişkin değere çalışma zamanında bakılarak karar verilemez. Zaten çoğu zaman da bu değer derleme zamanında bilinemez. 
	Yani hangi türlerin hangi türlere atanıp atanamayacağı bellidir. 
	
	Java'da genel olarak bilgi kaybına yol açmayacak doğrudan dönüşümler geçerlidir
	
	Anahtar Notlar: Java Language Specification'da temel türler arasında, uzunluk (size) olarak büyük olan türden, uzunluk
	olarak küçük olan türe yapılan dönüşüme "daraltma dönüşümü (narrowing conversion)", uzunluk olarak küçük olan türden 
	büyük olan türe	yapılan dönüşüme "genişletme dönüşümü (widening conversion)" denir.
	
	Doğrudan dönüşüme ilişkin ayrıntılar aşağıda anlatılacaktır
	

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı Türlerin Birbirine Atanması (Tür dönüşümleri-Type Conversions)
	
	
	Aşağıdaki örnekte long türüne ilişkin değer çalışma zamanında belirlenir. Dolayısıyla derleyici istese de bu değeri
	bilemez. Derleyici açısından kural "long türünden int türüne doğrudan dönüşüm geçersizdir" biçimindedir. Dolayısıyla
	error oluşur
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayigiriniz : ");
		long a = Long.parseLong(kb.nextLine());
		
		int b;
		
		b = a; //error
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte long türüne ilişkin değer belli olsa da derleyici açısından bu bir değişkendir ve "long türünden
	int türüne doğrudan atama geçersizdir" kuralı uygulanır
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 10;
		
		int b;
		
		b = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan atama geçerlidir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		long b;
		
		b = a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türünden büyük tamsayı türüne doğrudan dönüşümde küçük tamsayı türüne ilişkin değer pozitif veya sıfır
	ise sayının yüksek anlamlı yeni bit değerleri 0(sıfır) ile beslenir. Eğer sayı negatif ise sayının işaretinin korunması
	için yüksek anlamlı bit değerleri 1(bir) ile beslenir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		short a = Short.parseShort(kb.nextLine());
		
		int b;
		
		b = a; 
		
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = 0x%04X%n", a);

		System.out.printf("b = %d%n", b);
		System.out.printf("b = 0x%08X%n", b);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Hiçbir türden char türüne doğrudan dönüşüm yapılamaz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 67;
		char ch;
		
		ch = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Hiçbir türden char türüne doğrudan dönüşüm yapılamaz
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		byte a = 67;
		char ch;
		
		ch = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan VE int türden olan bir sabit char türüne
	doğrudan atanabilir"
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = 67;

		System.out.printf("ch = %c%n", ch);
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki kurala istisna olarak "char türü sınırları içerisinde kalan VE int türden olan bir sabit char türüne
	doğrudan atanabilir"
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 67;
		char c1, c2, c3;
		c1 = -67; //error
		c2 = a; //error
		c3 = 67L; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	short türünden char türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		char c;
		
		a = 10;
		
		c = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char a;
		short c;
		
		a = 10000;
		
		c = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Anımsanacağı gibi Java'da byte ve short türden sabit yoktur. Ancak "sınırlar içerisinde olması koşuluyla int türden
	bir sabit byte/short türüne atanabilir"
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		byte c;
		 
		a = 10;
		b = 24;
		c = -129; //error
		c = 45L; //error
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıda anlatılan byte, short ve char türlerine ilişkin istisna kurallar geri dönüş değerinin geçici değişkene
	yapılan atama işlemi için de geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		
	}
}


class Sample{
	public static short foo() 
	{
		return 10;
	}
	
	public static char bar() 
	{
		return 22;
	}
	
	public static byte tar() 
	{
		return 102;
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıda anlatılan byte, short ve char türlerine ilişkin istisna kurallar metot çağrısında argümanlardan 
	parametrelere yapılan atama işleminde geçersizdir. Bu durumun detayları ileride ele alınacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		Sample.foo(10);  
		Sample.bar(2);
		Sample.tar(23);
	}
}


class Sample{
	public static void foo(short a) 
	{
		//
	}
	
	public static void bar(char a) 
	{
		//
	}
	
	public static void tar(byte a) 
	{
		///
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden kendisinden uzunluk olarak büyük tüm türlere doğrudan atama geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'D';
		double b;
		
		b = c;
		
		System.out.printf("b = %f%n", b);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Bütün tamsayı türlerinden gerçek sayı türlerine doğrudan atama geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 3_000_000_000L;
		float b;
		
		b = a;
		
		System.out.printf("b = %f%n", b);
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Gerçek sayı türlerinden tamsayı türlerine doğrudan atama geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 55.656;
		long b;
		
		b = a; //error
		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	float türünden double türüne doğrudan atama geçerlidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 55;
		double b;
		
		b = a; 		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne doğrudan atama geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 55;
		float b;
		
		b = a; //error		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte sabitin sonuna F konmazsa sabit double türden olduğundan atama geçersiz olur. Aşağıdaki örneği
	çalıştırarak yuvarlama hatasını gözlemleyiniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 55.2F;
		
		System.out.printf("a = %.12f%n", a);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türünden herhangi bir türe doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean a = false;
		int b;
		
		b = a;
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Herhangi bir türden boolean türüne doğrudan dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 123;
		boolean b;
		
		b = a; //error
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------
    Temel türler için doğrudan dönüşüm (implicit conversion) tablosu:
    byte	-> short, int, long, float, double
    short	-> int, long, float, double
    int		-> long, float, double
    long	-> float, double
    float	-> double
    char	-> int, long, float, double
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesi otomatik tür dönüşümü:
	İki operandlı bir operatör için derleyici önce operandların türüne bakar. Operandlar farklı türdense ve işlem
	geçerliyse, ortak bir türe dönüştürülerek işlem yapılır. Hatta bazı durumlarda iki tür aynı olsa bile ikisini de farklı
	türe dönüştürür. Yani derleyici buna yönelik kodlar üretir. Bu dönüştürmeye "işlem öncesi otomatik tür dönüşümü" denir.
	
	Bu kuralın özeti "genel olarak küçük türe ilişkin değer büyük türe dönüştürülür. Sonuç büyük türden çıkar
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		long b;
		long c;
		
		a = 10;
		b = 22;
		c = a + b;
		
		System.out.printf("c = %d%n", c);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Her iki operand da byte, short veya char türlerindense ikisi birden işlem öncesinde int türüne dönüştürülür ve sonuç
	int türden çıkar. Buna "integral/integer promotion" denir
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		short b;
		short c;
		
		a = 10;
		b = 22;
		
		c = a + b; //error
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Her iki operand da byte, short veya char türlerindense ikisi birden işlem öncesinde int türüne dönüştürülür ve sonuç
	int türden çıkar. Buna "integral/integer promotion" denir
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		short a;
		byte b;
		short c;
		
		a = 10;
		b = 22;
		
		c = a + b; //error
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bölme işleminde her iki operand da tamsayı türlerine ilişkinse sonuç tamsayı türünden çıkar. Bölme işlemi yapılır, 
	elde edilen değerin noktadan sonraki kısmı atılır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 4;
		double c;
		
		c = a / b;
		
		System.out.printf("c = %f%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir gerçek sayı türü ile bir tamsayı türü işleme sokulduğunda dönüşüm gerçek sayı türüne doğrudur. Yani tamsayı türüne
	ilişkin değer gerçek sayı türüne dönüştürülür. Sonuç o gerçek sayı türünden çıkar
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 10.4F;
		long b = 4;
		float c;
		
		c = a + b;
		
		System.out.printf("c = %f%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Küçük tamsayı türü ile büyük tamsayı türü işleme sokulduğunda dönüşüm büyük tamsayı türüne doğrudur. Sonuç büyük
	tamsayı türünden çıkar. 
	Dikkat: Integral promotion bu kuralın dışındadır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b = 4;
		long c;
		
		c = a + b;
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türü hiçbir tür ile işleme sokulamaz
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean a = false;
		long b = 4;
		long c;
		
		c = a + b; //error
		
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	char türü herhangi bir tür ile işleme sokulabilir. Bu durumda char türüne ilişkin değer diğer türe dönüştürülür.
	Dikkat: Yine integral promotion bu durumun dışındadır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 21;
		char c = 'D';
		int result;
		
		result = a + c; 
		
		System.out.println(result);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesinde otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan
	kodu üretir. Örnekte derleyici ** ile belirtilen işlem için aşağıdakine benzer bir kod üretecektir:
		long temp = b;
		c = a + temp;
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 21;
		int b = 12;
		long c;
		
		c = a + b; //**
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	İşlem öncesinde otomatik tür dönüşümü geçici değişken yaratılarak yapılır. Yani derleyici geçici değişken yaratan
	kodu üretir. Örnekte derleyici ** ile belirtilen işlem için aşağıdakine benzer bir kod üretecektir:
		int temp1 = a;
		int temp2 = b;
		c = temp1 + temp2;
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		short a = 21;
		byte b = 12;
		int c;
		
		c = a + b; //**
		
		System.out.printf("c = %d%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Tür dönüştürme (type cast) operatörü:
	Tür dönüştürme operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. Tür dönüştürme
	operatörünün genel biçimi:	
		(<hedef tür ismi>)<ifade>
		
	Bu operatör operandına ilişkin ifadenin hedef türe dönüştürüldükten sonra elde edilen değeri üretir. Tür dönüştürme
	operatörü ile yapılan dönüşüme "explicit conversion" denir. Genel olarak implicit olarak geçersiz olan dönüşümler 
	tür dönüştürme operatörü ile yapılabilir. Şüphesiz bu durumda bilgi kaybı oluşabilir. Bu bilgi kaybının nasıl olacağı da
	bellidir ve ileride ele alınacaktır
	
	implicit olarak geçerli olan dönüşümler için de tür dönüştürme operatörü kullanılabilir. Gerekli olduğu durumlar 
	vardır. 
	
	Anahtar Notlar: Tür dönüştürme operatörünün sentaks ve semantik olarak zorunlu olması durumu genel olarak 
	"işlem doğrudan yapılsaydı problem olabilirdi. Bu sebeple derleyici bunu doğrudan yapmamazı istemiyor. Biz yapmak
	istersek tür dönüştürme operatörü kullanarak derleyiciye durumun farkındayım bana izin ver" anlaşılmalıdır
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 21;
		int b = 12;
		double c;
		
		c = (double)a / b;
		
		System.out.printf("c = %f%n", c);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Tür dönüştürme operatörü
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b;

		b = (int)a;
		
		System.out.printf("b = %d%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	implicit olarak geçerli olan dönüşümler için de tür dönüştürme operatörü kullanılabilir. Aşağıdaki örnekte bunun
	bir anlamı yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		long b;

		b = (long)a;
		
		System.out.printf("b = %d%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde kaynak türe ilişkin değer hedef türün
	sınırları içerisinde kalıyorsa bilgi kaybı oluşmaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 10;
		int b;

		b = (int)a;
		
		System.out.printf("b = %d%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Büyük tamsayı türünden küçük tamsayı türüne yapılan explicit dönüşümde kaynak türe ilişkin değer hedef türün
	sınırları içerisinde kalmıyorsa bilgi kaybı oluşur. Çünkü bu işlem yüksek anlamlı byte değerlerinin atılması
	biçiminde yapılır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		long a = 1_000_000_000_000L;  // 010101010010101010100101010100101
		int b;     

		b = (int)a;               //101010100101010100101
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		long a = Long.parseLong(kb.nextLine());
		int b;     

		b = (int)a;        
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %016X%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %08X%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	short türünden char türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		short a = Short.parseShort(kb.nextLine());
		char b;     

		b = (char)a;        
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %04X%n", a);
		System.out.printf("(int)b = %04X%n", (int)b);
		System.out.printf("b = %c%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	char türünden short türüne yapılan explicit dönüşümde sayının bit kalıbı değişmez. Sayının yorumlanışı değişir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		char a = '\uF0AC';
		short b;     

		b = (short)a;        
		
		System.out.printf("(int)a = %X%n", (int)a);
		System.out.printf("(int)a = %d%n", (int)a);
		System.out.printf("a = %c%n", a);
		System.out.printf("b = %X%n", b);
		System.out.printf("b = %d%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	boolean türünden herhangi bir türe explicit dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean a = true;
		int b;
		
		b = (int)a; //error
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Herhangi bir türden boolean türüne explicit dönüşüm geçersizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 1;
		boolean b;
		
		b = (boolean)a; //error
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	byte türünden char türüne explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne dönüştürülür. İkinci
	aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür (widening and narrowing conversion). 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		byte a = 99;//1 byte  derleyici int 4 byte  0000000000000000000000101010101
		char c; //char 2 byte
		
		c = (char)a; // 000000101010101
		
		System.out.printf("a = %X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(int)c = %04X%n", (int)c);
		System.out.printf("c = %c%n", c);
	
	}
	
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	byte türünden char türüne explicit dönüşüm iki aşamada gerçekleşir. Birinci aşamada değer int türüne dönüştürülür. İkinci
	aşamada yüksek anlamlı 2 byte atılarak char türüne dönüştürülür (widening and narrowing conversion). 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		//1001 1110   ---->  1111 1111 1111 1111 1111 1111 1001 1110
		
		//1111 1111 1001 1110
		
		byte a = -62;//1 byte 
		char c; //char 2 byte
		
		c = (char)a; 
		
		System.out.printf("a = %X%n", a);
		System.out.printf("(int)a = %08X%n", (int)a);
		System.out.printf("(int)c = %04X%n", (int)c);
		System.out.printf("c = %c%n", c);
	
	}
	
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	double türünden float türüne explicit dönüşümde bilgi kaybı olabilir. Bu durumda IEEE 754 standardına göre yuvarlama
	hataları oluşur ve değer float türünde temsil edilebilecek değer olarak elde edilir. Ayrıca sayı float sınırları dışında
	ise de aynı şekilde yapılır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 5.34; 
		float b;
		
		b = (float)a; 
		
		System.out.printf("a = %.20f%n", a);
		System.out.printf("b = %.20f%n", b);
	
	}
	
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Gerçek sayı türünde tamsayı türüne (veya char türüne) yapılan explicit dönüşüm şu şekilde gerçekkeşir:
	- Sayının noktadan sonraki kısmı atılır
		- Elde edilen sayı hedef türün sınırları içerisinde kalıyorsa hedef türe atanır 
		- Elde edilen sayı hedef türün sınırları içerisinde kalmıyorsa
			- Hedef tür byte, short, int ve char türlerinden biriyse
				- Elde edilen değer int türü sınırları içerisindeyse int türüne dönüştürülür. Buradan elde edilen değer
				tamsayılar arasındaki dönüşüm kurallarına göre hedef türe atanır
				- Elde edilen değer int türü sınırları içerisinde değilse değerin pozitif ya da negatif olması durumuna
				göre int türünün en büyük veya en küçük değeri alınır ve hedef türe dönüştürülür
			- Hedef tür long ise
				- Elde edilen değer long türü sınırları içerisindeyse doğrudan atanaır				
				- Elde edilen değer long türü sınırları içerisinde değilse sayının pozitif veya negatif olması durumuna
				göre long türünün en büyük veya en küçük değeri alınır ve atanır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 348.34; 
		int b;
		
		b = (int)a; 
		
		System.out.printf("b = %d%n", b);
	
	}
	
	
}





package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 100.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("b = %d%n", b);
	
	}	
}





package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 2345.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("2345 = %08X%n", 2345);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = -2345.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("-2345 = %08X%n", -2345);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	
	}	
}





package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = -1234.34; 
		short b;
		
		b = (short)a; 
		
		System.out.printf("-1234 = %08X%n", -1234);
		System.out.printf("b = %02X%n", b);
		System.out.printf("b = %d%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.34; 
		int b;
		
		b = (int)a; 
		
		System.out.printf("5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = -5_000_000_000.34; 
		int b;
		
		b = (int)a; 
		
		System.out.printf("-5_000_000_000 = %08X%n", (int)-5_000_000_000L);
		System.out.printf("b = %d%n", b);
		System.out.printf("b = %X%n", b);
	
	}	
}




package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 5_000_000_000.34; 
		byte b;
		
		b = (byte)a; 
		
		System.out.printf("-5_000_000_000 = %08X%n", (int)5_000_000_000L);
		System.out.printf("2147483647 = %d, %08X%n", 2147483647, 2147483647);		
		System.out.printf("b = %d, %X%n", b, b);	
	
	}	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan int türden sayıların ortalamasını bulan programı yazınız.
	Açıklamalar: Toplam değeri ve toplam girilen değerlerin sayısı int olarak tutulacaktır 
	
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindAverageApp.run();	
	
	}	
}

class FindAverageApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Sayileri girmeye baslayınız : ");
		int sum = 0, count = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			sum += val;
			++count;
		}
		
		double average = (double)sum / count;
		System.out.printf("Ortalama : %f%n", average);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan int türden sayıların ortalamasını bulan programı yazınız.
	Açıklamalar: Toplam değeri ve toplam girilen değerlerin sayısı int olarak tutulacaktır 
	
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindAverageApp.run();	
	
	}	
}

class FindAverageApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Sayileri girmeye baslayınız : ");
		int sum = 0, count = 0;
				
		for(int a = 0; (a = Integer.parseInt(kb.nextLine())) != 0; ++count, sum += a)
			;
		
		double average = (double)sum / count;
		System.out.printf("Ortalama : %f%n", average);
	}
}

/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte tür dönüştürme operatörü kullanılmazsa bilgi kaybı oluşabilir
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz:");
		int b = Integer.parseInt(kb.nextLine());		
		long c;
		
		c = (long)a + b;
		
		System.out.printf("c = %d%n", c);		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		
		for (int i = 0; i < 4; ++i) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			sum += a;
		}
		
		double avg = sum / 4.;
		
		System.out.printf("Ortalama:%f%n", avg);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	
	Aşağıdaki örnekte double türden sabit kullanıldığından işlem double olarak yapılır
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		
		for (int i = 0; i < 4; ++i) {
			System.out.print("Bir sayı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
			
			sum += a;
		}
		
		double avg = sum / 4D;
		
		System.out.printf("Ortalama:%f%n", avg);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	İşlemli atama operatörlerinin esas çalışma biçimi:
	
	T1 a;
	T2 b;
	
	a op= b => a = (T1)(a op b)
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{		
		int a = 10;
		int b = 20;
		
		a += Math.sqrt(b); //a = (int)(a + Math.sqrt(b));
		
		
		//...
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Bir sayının basamak sayısının log10  ile bulunması 
----------------------------------------------------------------------------------------------------------------------*/
package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		int count = 1;
		
		if (a != 0)
			count = (int)Math.log10(Math.abs(a)) + 1;
	
		System.out.printf("%d sayısının basamak sayısı:%d%n", a, count);	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153	 
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		IsArmstrongTest.run();
	}
}

class IsArmstrongTest {
	public static void run()
	{
		for (int a = -10; a <= 999999; ++a)
			if (NumberUtil.isArmstrong(a))
				System.out.println(a);	
	}
}

class NumberUtil {
	public static boolean isArmstrong(int a)
	{
		return a >= 0 && getDigitsPowSum(a) == a;				
	}
	
	public static int getDigitsPowSum(int a)
	{
		int n = countDigits(a);
		int total = 0;
		
		while (a != 0) {
			total += Math.pow(a % 10, n);
			a /= 10;					
		}
		
		return total;
	}	
	
	public static int countDigits(int a)
	{
		if (a == 0)
			return 1;
		
		return (int)Math.log10(Math.abs(a)) + 1;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
10.01.2023 Salı - 15.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	 Koşul Operatörü (conditional operator): Koşul operatörü özel amaçlı, üç operandlı (ternary) ve araek durumunda
	 bir operatördür. Operatörün genel biçimi:
	 
	 <operand1> ? <operand2> : <operand3>
	 
	 
	 operand1: boolean türden bir ifade olamalıdır. 
	 
	 
	 if(a < b)
	 	min = a;
	 else
	 	min = b
	 	
	 	
	 	bu ilişkiyi koşul operatörü ile yapabilirmiyim?
	 
	  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	 if(a < b)
	 	min = a;
	 else
	 	min = b;
	 	
	 	bu ilişkiyi koşul operatörü ile yapabilirmiyim?
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int min;
		
		 min = a < b ? a: b;
		 
		 System.out.printf("min(%d, %d) = %d%n", a, b, min);
	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int result;
		
		 result = a < b ? a: b - 100;
		 
		 System.out.printf("result = %d%n", result);
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örnekte koşul operatörünün ürettiği değerden 100 çıkartılacaktır. Parantaz ile bu sağlanmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int result;
		
		 result = (a < b ? a: b) - 100;
		 
		 System.out.printf("result = %d%n", result);
	
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
	 	kısa devre davranısını unutmyalım
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int result;
		
		result = a > 0 && a < b ? a: b;
		 
		System.out.printf("result = %d%n", result);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
	 	kısa devre davranısını unutmyalım
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
	
		int min;
		
		min = a < b ? a: b;
		 
		System.out.printf("result = %d%n", min);
	
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		 
		System.out.printf("result = %d%n", Util.min(a, b));
	
	}
}

class Util{
	public static int min(int a, int b) 
	{
		return a < b ? a : b;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Aşağıdaki örneği inceleyelim
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		 
		System.out.printf("result = %d%n", a < b ? a : b);
	
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153	 
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

import java.util.Iterator;

class App {	
	public static void main(String [] args)
	{
		IsAmrstrongTest.run();
	
	}
}

class IsAmrstrongTest{
	public static void run() 
	{
		for(int a = -10; a <= 999999; ++a)
			if(NumberUtil.isArmstrong(a))
				System.out.println(a);
	}
}

class NumberUtil{
	public static boolean isArmstrong(int a) 
	{
		return a >= 0 && getDigitsPowSum(a) == a;
	}
	
	public static int getDigitsPowSum(int a) 
	{
		int n = countDigits(a);
		int total = 0;
		while (a != 0) {
			total += Math.pow(a % 10, n);
			a /= 10;
		}
		
		return total;
	}
	
	public static int countDigits(int a) 
	{
		return a == 0 ? 1 : (int)Math.log10(Math.abs(a)) + 1;
	}
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
	 	Sınıf Çalışması: Parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin aşağıdaki açıklamalara
	göre haftanın hangi gününe geldiğini döndüren getDayOfWeek isimli metodu yazınız ve aşağıdaki kod ile test ediniz.
	Açıklamalar:
		- Metot geçersiz bir tarih durumunda -1 değerine geri dönecektir
		- Haftanın günü 1.1.1900 ile verilen tarih arasındaki (verilen tarih dahil) gün sayısının 7(yedi) ile bölümünden 
		elde edilen kalan ile belirlenebilir. Buna göre değer sıfır ise "pazar", 1 ise "pazartesi", ..., 6 ise "cumartesi"
		günlerine karşılık gelir
		
		- 1.1.1900 öncesindeki tarihler geçersiz sayılacaktır
		- getDayOfWeek metodu ile birlikte 
				
		- İleride daha iyisi yazılacaktır parametresi ile aldığı int türden gün, ay ve yıl bilgilerine ilişkin tarihin
		hafta sonu olup olmadığınıu test eden isWeekend ve hafta içi olup olmadığını test eden isWeekday metotlarını yazınız.
		Bu iki metot tarih geçerlilik kontrolü yapmayacaktır
		
		- İleride daha yazılacaktır
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		GetDayOfWeekTest.run();		
	}
}

class GetDayOfWeekTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Gün ay ve yıl bilgilerini giriniz?");
			int day = kb.nextInt();
			int month = kb.nextInt();
			int year = kb.nextInt();
			
			if (day == 0)
				break;
			
			DateUtil.printDateTR(day, month, year);
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class DateUtil {
	public static void printDateTR(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		if (dayOfWeek == -1) {
			System.out.println("Geçersiz tarih");
			return;
		}
		
		switch (dayOfWeek) {
		case 0 -> System.out.printf("%02d/%02d/%04d Pazar%n", day, month, year);
		case 1 -> System.out.printf("%02d/%02d/%04d Pazartesi%n", day, month, year);
		case 2 -> System.out.printf("%02d/%02d/%04d Salı%n", day, month, year);			
		case 3 -> System.out.printf("%02d/%02d/%04d Çarşamba%n", day, month, year);			
		case 4 -> System.out.printf("%02d/%02d/%04d Perşembe%n", day, month, year);
		case 5 -> System.out.printf("%02d/%02d/%04d Cuma%n", day, month, year);		
		case 6 -> System.out.printf("%02d/%02d/%04d Cumartesi%n", day, month, year);			
		}
		
		System.out.println(isWeekend(day, month, year) ? "Bugün kurs var. Tekrar yaptınız mı?" : "Kurs günü yaklaşıyor. Tekrar yapmayı unutmayınız"); // ifade daha kısaltılabilir. İleride göreceğiz
		
	}

	
	public static int getDayOfWeek(int day, int month, int year)
	{
		int totalDays;
		
		if (year < 1900 || (totalDays = getDayOfYear(day, month, year)) == -1)
			return -1;
		
		for (int y = 1900; y < year; ++y) 
			totalDays += isLeapYear(y) ? 366 : 365;
		
		return totalDays % 7;
	}

	public static boolean isWeekend(int day, int month, int year)
	{
		int dayOfWeek = getDayOfWeek(day, month, year);
		
		return dayOfWeek == 0 || dayOfWeek == 6;
	}
	
	public static boolean isWeekday(int day, int month, int year)
	{
		return !isWeekend(day, month, year);
	}
	
	public static int getDayOfYear(int day, int month, int year)
	{
		if (!isValidDate(day, month, year))
			return -1;
		
		int totalDays = day;
		
		switch (month - 1) {
		case 11:
			totalDays += 30;
		case 10:
			totalDays += 31;
		case 9:
			totalDays += 30;
		case 8:
			totalDays += 31;
		case 7:
			totalDays += 31;
		case 6:
			totalDays += 30;
		case 5:
			totalDays += 31;
		case 4:
			totalDays += 30;
		case 3:
			totalDays += 31;
		case 2:
			totalDays += isLeapYear(year) ? 29 : 28;
		case 1:
			totalDays += 31;			
		}
		
		return totalDays;
	}
	
	public static boolean isValidDate(int day, int month, int year)
	{		
		return  1 <= day && day <= 31 && 1 <= month && month <= 12 && day <= getDays(month, year);		
	}
	
	public static int getDays(int month, int year)
	{
		int days;
		
		days = switch (month) {
			case 4, 6, 9, 11 -> 30;		
			case 2 -> isLeapYear(year) ? 29 : 28;			
			default -> 31;			
		};
		
		return days;
	}
	
	public static boolean isLeapYear(int year)
	{
		return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	 Koşul operatörünün ikinci ve üçüncü operandı void bir ifade olamaz
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		a < b ? Sample.foo() : Sample.bar(); //errror
		
	}
}



class Sample{
	public static void foo() 
	{
		System.out.println("foo");
	}
	
	public static void bar() 
	{
		System.out.println("bar");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	 Yukarıdaki örnekte çözğmleme bu sekilde yapılır
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		if(a < b)
			Sample.foo();
		else
			Sample.bar();
		
	}
}



class Sample{
	public static void foo() 
	{
		System.out.println("foo");
	}
	
	public static void bar() 
	{
		System.out.println("bar");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	Koşul operatörünün bir kullanımı. Örnekte parantez kullanımına sentaks açısından gerek yoktur
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		

		System.out.print("Üçüncü sayiyi giriniz : ");
		int c = Integer.parseInt(kb.nextLine());
		
		int min;
				
		min = a < b ? a < c ? a : c : b < c ? b : c;
		
		System.out.printf("min = %d%n", min);
		
	}
}






/*----------------------------------------------------------------------------------------------------------------------	 
		 	
	Yukarıdaki örnekte koşul operatörünün operandlarını parantez içerisine almak okunabilirliği artırır
	
	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		

		System.out.print("Üçüncü sayiyi giriniz : ");
		int c = Integer.parseInt(kb.nextLine());
		
		int min;
				
		min = (a < b) ? (a < c ? a : c) : (b < c ? b : c);
		
		System.out.printf("min = %d%n", min);
		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------


Method Overloading: 

	Bir sınıf içerisinde aynı isimde metot yazılması durumuna "method overloading" denir.
	Bu kavram aynı isimde fakat farklı sınıflarda olan metotlar için geçerli değildir.



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki durum "method overloading" değildir. Çünkü aynı isimde olan metotlar farklı sınıflardadır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		Sample.foo();
		Mample.foo();
		
	}
}

class Sample{
	public static void foo() 
	{
		System.out.println("Sample.foo");
	}
}

class Mample{
	public static void foo() 
	{
		System.out.println("Mample.foo");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Bir sınıf içerisinde AYNI metottan birden fazla olamaz. Bu durumda bir metodun "overload" edilebilmesi
	için kendisiyle aynı isimde olanlardan FARKLI olması gerekir. Aşağıdaki maddelerde metodun AYNI ya da FARKLI olmasına
	ilişkin detaylar anlatılmaktadır 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun erişim belirleyicisinin "overload" işlemine etkisi yoktur. Yani errişim belirleyicilerin farklı olması
	metodu farklı yapmaz 
	
	 Bir sınıf içerisinde AYNI metottan birden fazla olamaz. Bu durumda bir metodun "overload" edilebilmesi
	için kendisiyle aynı isimde olanlardan FARKLI olması gerekir.
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun static olup olmamasının da overload işlemine etkisi yoktur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun geri dönüş değeri bilgisinin de overload işlemine etkisi yoktur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo() //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public static int foo() //ERROR 
	{
		System.out.println("Sample.foo");
		
		return 10;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun parametre isimlerinin de overload işlemine etkisi yoktur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	

		
	}
}

class Sample{
	public static void foo(int a, int b) //ERROR 
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a, int b) //ERROR 
	{
		System.out.println("Sample.foo");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun "overload" edilebilmesi için metodun parametre tür bilgisi ve parametrelerin diziliminin farklı olması 
	gerekir.  Buna genel olarak "parametrik yapı" diyebiliriz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
	}
}

class Sample{
	public static void foo() 
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a) 
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo(double a) 
	{
		System.out.println("Sample.foo double");
	}
	
	public static void foo(int a, double b) 
	{
		System.out.println("Sample.foo int double");
	}
	
	public static void foo(double a, int b) 
	{
		System.out.println("Sample.foo double int");
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir sınıf içerisinde metodun ismi ve parametrik yapısının ikisine birden o metodun "imzası (signature)" diyelim.
	 
	Kural: Bir sınıf içerisinde aynı imzaya sahip 1(bir)'den fazla metot bildirimi geçersizdir  	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
	}
}

class Sample{
	public static void foo()  //foo
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a)  //foo, int
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo(double a)  //foo, double
	{
		System.out.println("Sample.foo double");
	}
		
	public static void foo(int a, double b) //foo , int , double
	{
		System.out.println("Sample.foo int double");
	}
	
	public static void foo(double a, int b) //foo, double, int
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void bar() //bar 
	{
		System.out.println("Sample.bar ");
	}
	
	public static void bar(int a) //bar, int
	{
		System.out.println("Sample.bar int");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metot çağrısında derleyicinin hangi metodun çağrılacağına karar vermesi sürecine "method overload resolution"
	ya da kısaca "overload resolution" denir  	 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	 Metot çağrısında argümanlar ile karşılık geldikleri parametrelerin türlerinin aynı olduğu o isimde bir metot sınıf
	 içerisinde varsa o çağrılır (best match)  	 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10, b = 20;
		double c = 30;
		
		Sample.foo(c, b);
	}
}

class Sample{
	public static void foo()  //foo
	{
		System.out.println("Sample.foo");
	}
	
	public static void foo(int a, int b)  //foo,int,int
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(int a)  //foo, int
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo(double a)  //foo, double
	{
		System.out.println("Sample.foo double");
	}
		
	public static void foo(int a, double b) //foo , int , double
	{
		System.out.println("Sample.foo int double");
	}
	
	public static void foo(double a, int b) //foo, double, int
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void bar() //bar 
	{
		System.out.println("Sample.bar ");
	}
	
	public static void bar(int a) //bar, int
	{
		System.out.println("Sample.bar int");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
 	 Tam uyum (best match) yoksa overload resolution işlemi aşağıdaki gibi yapılır:
	 1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimde olan tüm metotlardır.
	 
	 2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki, parametre sayısı çağrıdaki argüman
	 sayısı ile aynı olan ve argümanlardan karşılık geldikleri parmetrelere otomatik (implicit) tür dönüşümünün geçerli
	 olduğu metotlardır.
	 
	 3. En uygun metot (the most applicable method) belirlenir: Uygun metotlar içerisinde daha kaliteli, ya da daha kalitesiz
	 olmayan dönüşümü sunan metottur. Ya da başka bir deyişle "en uygun metot öyle bir metottur ki, argümanlardan parametrelere
	 yapılan dönüşümler kalite olarak yarışa sokulduğunda daha iyi ya da daha kötü olmayan dönüşümü sunar"
	 
	 Dönüşümün kalitesi aşağıdaki kurallara göre belirlenir:
	 T1 argümanın türü, T2 ve T3 yarıştırılan uygun metotların T1'e ilişkin argümana karşılık geldiği parametresinin 
	 türleri olsun:
	 
	 1. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2 veya T3'den biri T1 ile aynı ise aynı olan dönüşüm daha kalitelidir.
	 Örneğin:
	 int -> int *
	 int -> double
	 
	 2. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2'den T3'e otomatik dönüşüm var, T3'den T2'ye otomatik dönüşüm yok ise
	 T2 kalitelidir
	 Örneğin:
	 int -> long *
	 int -> float
	 
	 ya da örneğin
	 
	 short -> int *
	 short -> double
	 
	 
	 Burada aday metotlar bulunamazsa VEYA aday metotlar var ancak uygun metotlar bulunamazsa VEYA uygun metotlar var ancak
	 en uygun metot yoksa error oluşur. 	 
	 
	 Yukarıdaki anlatım "overload resolutiıon" kavramının basitleştirilmiş bir anlatımıdır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4, 5
 	2. Uygun metotla: 1, 2, 3
 	3. En uygun metot: 1
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		short b = 20;
		
		Sample.foo(a, b);
	}
}

class Sample{
	public static void foo(int a, int b)  //#1
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(double a, int b)  //#2
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, long b)  //#3
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	 Tam uyum (best match) yoksa overload resolution işlemi aşağıdaki gibi yapılır:
	 1. Aday metotlar (candidate methods) belirlenir: Çağrılan metot ile aynı isimde olan tüm metotlardır.
	 
	 2. Uygun metotlar (applicable methods) belirlenir: Aday metotlar içerisindeki, parametre sayısı çağrıdaki argüman
	 sayısı ile aynı olan ve argümanlardan karşılık geldikleri parmetrelere otomatik (implicit) tür dönüşümünün geçerli
	 olduğu metotlardır.
	 
	 3. En uygun metot (the most applicable method) belirlenir: Uygun metotlar içerisinde daha kaliteli, ya da daha kalitesiz
	 olmayan dönüşümü sunan metottur. Ya da başka bir deyişle "en uygun metot öyle bir metottur ki, argümanlardan parametrelere
	 yapılan dönüşümler kalite olarak yarışa sokulduğunda daha iyi ya da daha kötü olmayan dönüşümü sunar"
	 
	 Dönüşümün kalitesi aşağıdaki kurallara göre belirlenir:
	 T1 argümanın türü, T2 ve T3 yarıştırılan uygun metotların T1'e ilişkin argümana karşılık geldiği parametresinin 
	 türleri olsun:
	 
	 1. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2 veya T3'den biri T1 ile aynı ise aynı olan dönüşüm daha kalitelidir.
	 Örneğin:
	 int -> int *
	 int -> double
	 
	 2. T1 -> T2 ve T1 -> T3 otomatik dönüşümlerinde T2'den T3'e otomatik dönüşüm var, T3'den T2'ye otomatik dönüşüm yok ise
	 T2 kalitelidir
	 Örneğin:
	 int -> long *
	 int -> float
	 
	 ya da örneğin
	 
	 short -> int *
	 short -> double
	 
	 
	 Burada aday metotlar bulunamazsa VEYA aday metotlar var ancak uygun metotlar bulunamazsa VEYA uygun metotlar var ancak
	 en uygun metot yoksa error oluşur. 	 
	 
	 Yukarıdaki anlatım "overload resolutiıon" kavramının basitleştirilmiş bir anlatımıdır 
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4, 5
 	2. Uygun metotlar: 3
 	3. En uygun metot: 3
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		double b = 20;
		
		Sample.foo(a, b);

	}
}

class Sample{
	public static void foo(double a, int b)  //#1
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, float b)  //#2
	{
		System.out.println("Sample.foo int float");
	}
	
	public static void foo(int a, double b)  //#3
	{
		System.out.println("Sample.foo int double");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int");
	}
}





/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: yok
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		float b = 20;
		
		Sample.fo(a, b);

	}
}

class Sample{
	public static void foo(int a, int b)  //#1
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(double a, int b)  //#2
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, double b)  //#3
	{
		System.out.println("Sample.foo int double");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4, 5
 	2. Uygun Metotlar: yok
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		float b = 20;
		
		Sample.foo(a, b); //error

	}
}

class Sample{
	public static void foo(int a, int b)  //#1
	{
		System.out.println("Sample.foo int int");
	}
	
	public static void foo(double a, int b)  //#2
	{
		System.out.println("Sample.foo double int");
	}
	
	public static void foo(int a, long b)  //#3
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#4
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#5
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#6
	{
		System.out.println("Sample.bar int double");
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
 	1. Aday Metotlar: 1, 2, 3, 4
 	2. Uygun Metotlar: 1, 2
 	3. En uygun metot: yok
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		
		Sample.foo(a, b); //error, ambiguity

	}
}

class Sample{
	public static void foo(long a, int b)  //#1
	{
		System.out.println("Sample.foo long int");
	}
	
	public static void foo(int a, long b)  //#2
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#3
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#4
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#5
	{
		System.out.println("Sample.bar int double");
	}
}





/*----------------------------------------------------------------------------------------------------------------------	 
 	tam uyum var best macth
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		
		Sample.foo((long)a, (int)b); 

	}
}

class Sample{
	public static void foo(long a, int b)  //#1
	{
		System.out.println("Sample.foo long int");
	}
	
	public static void foo(int a, long b)  //#2
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#3
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#4
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#5
	{
		System.out.println("Sample.bar int double");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	1.Aday metotlar : 1, 2, 3, 4
 	2. Uygun metotlar: 1
 	3. En uygun metot: 1
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		short b = 20;
		
		Sample.foo((long)a, b); 

	}
}

class Sample{
	public static void foo(long a, int b)  //#1
	{
		System.out.println("Sample.foo long int");
	}
	
	public static void foo(int a, long b)  //#2
	{
		System.out.println("Sample.foo int long");
	}
		
	public static void foo(int a) //#3
	{
		System.out.println("Sample.foo int");
	}
	
	public static void foo() //#4
	{
		System.out.println("Sample.foo");
	}
	
	public static void bar(int a, double b) //#5
	{
		System.out.println("Sample.bar int double");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
 	1.Aday metotlar : 1, 2, 3, 4
 	2. Uygun metotlar: 1, 2, 3, 4
 	3. En uygun metot: 1
 	
 	
 	T1 ->T2 T1-> T3------  T2 -> T3 ve T2 ye donusmuyor T2
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		short a = 10;
		
		MyMath.abs(a); 

	}
}

class MyMath{
	public static int abs(int a)  //#1
	{
		System.out.println("MyMath.abs int");
		return a < 0 ? -a : a;
	}
	
	public static double abs(double a)  //#2
	{
		System.out.println("MyMath.abs double");
		
		return a < 0 ? -a : a;
	}
		
	public static float abs(float a)  //#3
	{
		System.out.println("MyMath.abs float");
		
		return a < 0 ? -a : a;
	}
	
	public static long abs(long a)  //#4
	{
		System.out.println("MyMath.abs long");
		
		return a < 0 ? -a : a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
    12.01.2023 - Perşembe - 16.Ders

	Nesne Yönelimli Programalama Tekniği (NYPT): Bu tekniği tek bir cümle ile anlatmak pek mümkün değildir. Ancak bu 
	tekniğin detaylarını bilen bir kişiye "sınıflar kullanarak program yazma tekniğidir" şeklinde bir cümle söylenebilir.
	Aslında NYPT anahtar kavramların birleşiminden oluşur. Bu anahtar kavramlar birbirlerinden tamamen ayrık değildir. 
	Bu kavramlar içiçe geçmiş daireler gibi düşünülebilir. Tüm anahtar kavramların temelinde kodu daha iyi algılanabilir 
	olması ve daha iyi yönetilmesi vardır. Örneğin benzer işi yapan metotlara aynı ismi vermek iyi bir tekniktir. Çünkü 
	bu durumda bu metotları kullanan kişiler "çok şey var" duygusundan uzaklaşıp "az şey var" gibi bir algı oluştururlar.
	Bu da hatırlamayı kolaylaştırır.
	
	NYPT insanın doğayı algılayış biçimini model almıştır. İnsanlar herşeyi nesne biçiminde ele alıp onu kullanırlar. 
	Örneğin, elimizdeki bilgisayarlar farklı bile olsa konuşurken bizim için hepsi bilgisayardır. Gerekirse onların 
	başka özellikler ayrıca söylenebilir.
	
	NYPT'de artık ağırlıklı olarak fonksiyonlarla (Java'da metot) değil, sınıflarla konuşulur. Böylece yine "çok şey var"
	algısından uzaklaştırılıp "az şey var" algısı oluşturulur. Bu anlamda aslında kullanan programcı açısından detaylar
	metotların detayları gizlemesinden daha fazla gizlenebilir. Böylelikle kullanım kolaylaşır. Bunların detayları ileride
	daha iyi anlaşılacaktır 




	Değişkenlerin Ömürleri (storage duration):
	Bir değişkenin ömrü onun bellekte yer kapladığı zaman aralığıdır. Yani bir değişkenin ömrü o değişkenin bellekte
	yaratılmasıyla (yer ayrılmasıyla) yok edilmesi arasında geçen zaman aralığıdır.
	Anımsanacağı gibi bir değişkenin faaliyet alanı (scope) derleme zamanına ilişkindir. Ömür ise çalışma zamanına 
	ilişkindir. 
		
	
	Bir Java programı için çalışma zamanında "stack" ve "heap" denilern iki ayrı belek alanı yaratılır. Her uygulama 
	için bu alanlar ayrı olarak yaratılırlar. Aşağı seviyede başka alanlar da bulunur. Stack ve heap RAM'de organize
	organize edilir. Stack ve heap'in yeri (yani hangi adresten başladığı) ve uzunluğu sistemden sisteme değişebilmektedir.
	Program çalıştırılırken bu alanların uzunlukları belirlenebilirç. Belirlenmezse default değerler kullanılır. İşte bu
	default değerler sistemden sisteme farklı olabilir. 
	
	Stack'te yaratma ve yok etme işlemi birer makine komutuyla çok hızlı bir biçimde yapılır. Stack alanınde değişken
	yaratılması ve yok edilmesi stack veri yapısı ile gerçekleştirilir
	

	Veri yapısı (Data structure): Verileri belirli bir algoritmaya göre tutan ve verilere istenildiği zaman erişebilen
	yapılara denir.

	Stack veri yapısında eleman ekleme işlemine "push", eleman silme işlemine de "pop" denilmektedir.
	
	Anahtar Notlar: Stack veri yapısı "LIFO (Last In First Out)" kuyruk sistemine göre çalışan veri yapısıdır. LIFO'da
	ekleme sona yapılır. Eleman elde etme (ve silme) sondan yapılır. Yani son eklenen eleman elde edilir. Örneğin bir 
	pişti oyununda ortada biriken kağıtlar için bu veri yapısı kullanılabilir. Ya da örneğin editör programların 
	"undo-redo" işlemleri de stack veri yapısı ile gerçekleştirilebilir





/*----------------------------------------------------------------------------------------------------------------------	 
 	Yerel değişkenler ve parametre değişkenleri stack alanında yaratılırlar. Yerel bir değişken, akış bakımından bildirim
	noktasına gelindiğinde yaratılır, bildirildiği bloğun sonuna gelindiğinde yok edilir. Zaten değişkenlere faaliyet
	alanı bakımından bildirildikleri bloktan sonra erişilememesinin nedeni budur. Parametre değişkenleri metot çağrıldığında
	yaratılır, metot çağrısı bittiğinde yok edilir. 
	
	Anahtar Notlar: Her ne kadar faaliyet alanı (scope) ve ömür (storage duration) farklı zamanlara (compile or run) 
	ilişkin kavramlar olsa da aralarında mantıksal bir bağ söz konusudur. Yani aralarında dolaylı da olsa da bir ilişkin 
	bulunur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		//....
		//..
		
		{
			int a; //akış buraya geldi stack yaratılır
			double b = 4.5; // stackte yaratılı initialize edilir
		}//a ve b yok edilir 
		
		
		Sample.foo(5,  3.4); //metodun parametre değişkenleri yaratılır ve argümanlarına degerleri ilgili parametreler aktarılır 
		//metot çagrısı bittiginde parametre değişkneleride yok edilir
		
		
		//
		
		
		Sample.foo(12, 2.2);//metodun parametre değişkenleri yaratılır ve argümanlarına degerleri ilgili parametreler aktarılır 
		//metot çagrısı bittiginde parametre değişkneleride yok edilir
		
	}
}


class Sample{
	public static void foo(int a, double b) 
	{
		int x; //Akış buraya geldiğinde x stack'de yaratılır
		//..
		
		//..
	}//x in hayatı burada sonlanır
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf içerisindeki bildirimlere sınıfın elemanları (members) denir. Sınıfın elemanı bir alt programsa buna metot denir.
	Sınıfın elemanı bir değişken ise veri elemanı (member field/variable ya da yalnızca field) denir. Sınıfın başka 
	elemanları da olabilir. Bunlar ileride ele alaıncaktır  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın içerisinde tüm metotların dışında herhangi bir yerde bildirilen değişkenlere sınıfın veri elemanları denir.
	Sınıf veri elemanları da metotlarda olduğu gibi erişim belirleyiciye sahiptir, veri elemanları da static ve non-static
	olarak bildirilebilirler. Sınıf elemanlarının erişim belirleyiciler konusuna kdar tüm veri elemanlarını da public
	olarak bildireceğiz  
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class App {	
	public static void main(String [] args)
	{
		
	}
}

class Sapmle{
	
	public int a;
	private static double b;
	
	public static void foo(int x)
	{
		//...
		
	}
	
	protected int c;
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Bir sınıf içerisinde aynı isimde birden fazla veri elemanı bildirimi yapılamaz  
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class App {	
	public static void main(String [] args)
	{
	}
}

class Sapmle{
	
	public int a;
	private static double b; //error duplicate
	
	public static void foo(int x)
	{
		//...
		
	}
	
	protected int b;//error duplicate
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Birden fazla veri elemanı aynı türdense, static veya non-static olma durumları aynı ise, ve aynı erişim
	  belirleyiciye sahipse virgül ile ayrılarak yani listelenerek bildirim yapılabilir
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class App {	
	public static void main(String [] args)
	{
	}
}

class Sapmle{
	
	public int a, b;
	private static double d, c, y, t; 
	
	public static void foo(int x)
	{
		//...
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf bildirimi aslında bir tür bildirimidir (user defined type)
----------------------------------------------------------------------------------------------------------------------*/



package orhn;

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf bildirimi bir tür bildirimi olduğuna göre sınıf türünden değişkenler bildirilebilir. 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;


class App {	
	public static void main(String [] args)
	{
		int a;
		double b, c;
		
		Sensor s;
		Student stdnt;
		Person p;
		
	}
}

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Java'da türler kategori olarak iki gruba ayrılır: değer türleri (value types), referans türleri (reference types).
	 
	 T bir tür olmak üzere T türden bir değişken içerisinde tutulan değer bir adres iese bu durumda T bir referans türüdür.
	 Adres değilse T bir değer türüdür. Java'da temel türler değer türleridir. Yani temel türden bir değişken içerisinde
	 adres tutulmaz. Programcı tarafından bildirilen türler (user defined type) (sınıflar, enum sınıflar, interface'ler vb.)
	 referans türleridir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıf türünden bir değişkene (aslında referans türünden bir değişkene) "referans değişken" ya da kısaca "referans"
	 denir. 
	 
	 Anahtar Notlar: Java'da "referans" sözcüğü "adres" anlamında da kullanılır. Örneğin "bir nesnenin adresi" yerine
	 "bir nesnenin referansı" demek de aynıdır. Ancak buradaki referans terimi bir değişkeni değil adresi temsil eder.
	 "Referans değişken ya da kısaca referans" içerisinde adres (referans) tutan değişkendir.     
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		int a; //value type
		double b, c;
		
		Sensor s; // s bir referans 
		Student st; //st bir referans
		Person p;//p bir referans
		
	}
}

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  - Sınıf türünden bellekte ayrılan bir alana o sınıf türünden nesne (object) denir
	 
	 - Nesneler heap'de yaratılırlar. Java'da stack'te nesne yaratılamaz
	 
	 - Java'da nesnenin kendisi değil adresi aynı türden bir referansta tutulabilir
	 
	 - Bir nesneyi yaratmak için new operatörü kullanılır. new operatörü kullanımının genel biçimi:
	 	new <sınıf ismi>([argümanlar]);   
	 	
	 new operatörü özel amaçlı, tek operandlı (unary) ve önek (prefix) durumda bir operatördür. new operatörü nesne
	 yaratılması aaşamaları tamamlandıktan sonra heap'te yaratılmış olan nesnenin adresini (referansını) üretir. Bu durumda
	 bu operatörün ürettiği değer yani adres aynı türden bir referansa atanabilir
	 
	 - Bir nesne ilgili sınıf türünden bir örnektir. Buna "instance" da denir 
	 
	 
	 - Aşağıdaki örnekte, nesne yönelimli programlama anlamında "s" birer nesne DEĞİLDİR. Bunlar ilgili sınıflar
	 türünden referanslardır.  ** ile belirtilen deyimle birlikte "s referansı yaratılan nesneyi gösteriyor" duruma gelir.
	 
	 - Referans ve nesne kavramları birbirinden farklıdır. Referans değişken bir nesneyi gösterebilir	
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		Sensor s; //s bir referans (değişken)
		
		java.util.Scanner kb = new java.util.Scanner(System.in); 
				
		s = new Sensor(); //**
	}
}

class Sensor{
	//...
}

class Student{
	//..
	int id;
	String name;
	
}

class Person{
	//...
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Sınıfın non-static veri elemanları her nesne için ayrıca yaratılırlar ve nesnenin içerisinde bulunurlar. Sınıfon 
	non-static veri elemanlarına sınıf dışından (yani başka bir sınıfın içinden) referans ve nokta operatörü ile 
	erişilir. Nokta operatörü özel amaçlı, iki operandlı ve araek durumundadır. Nokta operatörünün birinci operandı bir
	referans, ikinci operandı bir veri elemanı ise bu durumda nokta operatörü o veri elemanına ilişkin değişkeni üretir.
	Aslında referans ve nokta operatörü ile veri elemanı ismi kullanımı o referansın gösterdiği nesnenin ilgili veri elemanına
	erişmek anlamına gelir. Her new işlemi yeni bir nesne yaratmak demektir
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		Sample s, k; //referans
		
		s = new Sample();
		k = new Sample();
		
		s.a = 10;
		s.b = true;
		
		k.a = 20;
		k.b = false;
		
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte s yerel değişkenine değer atanmadan kullanıldığı için error oluşur
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;




class App {	
	public static void main(String [] args)
	{
		Sample s; //referans

		s.a = 10; //error
		s.b = true; //error

		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);

		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Farklı türden referanslar birbirine tür dönüştürme operatörü ile bile atanamazlar 
	 	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s; //referans
		Mample m;

		s = new Sample();
		
		m = (Mample)s;

	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}

class Mample{
	public int a;
	public boolean b;
	
	//..
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Non-static veri elemanlarına nesnenin yaratılması aşamasında default değerler atanır. Default değer türe özgü
	mantıksal sıfır değeridir. Örneğin int türü için sıfırken, boolean türü için false değeridir 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k; //referans

		s = new Sample();
		k = new Sample();
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);

	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir nesnenin uzunluğu yani bellekte kapladığı alan "en az non-static veri elemanlarının toplam uzunluğu kadardır".
	Bu durumda aynı türden nesneler için aynı uzunlukta yer ayrılır. Farklı türden nesneler için farklı veri elemanları
	olabileceğinden aynı uzunlukta yer ayrılması gerekmez
	
	Türü ne olursa olsun referansların (referans değişkenlerin) uzunlukları aynıdır. Bu da adreslenebilecek sayıları
	tutabilecek uzunluktur. Örneğin 64 bit sistemlerde tüm referanslar 64 bit(8 byte) uzunluğundadır. Benzer şekilde 
	32 bit sistemlerde tüm referanslar 32 bit (4 byte) uzunluğundadır
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aynı türden iki referansın biribirine atanması iki referansın da artık aynı nesneyi göstermesi demektir. Bu durumda
	hangi referans ile nesneye erişildiğinin bir önemi yoktur. Aşağıdaki örnekte **'da s referansı gösterdiği nesneden 
	kopartılmış ve k'nın içerisindeki adres atandığından artık k ve s aynı nesneyi gösterir duruma gelmiştir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k; //referans

		s = new Sample(); 
		k = new Sample(); 
		
		s.a = 20;
		s.b = true;
		
		k.a = 15;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("***************************************");
		
		s = k; //**

		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("***************************************");
		
		++s.a;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("***************************************");
		
		
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte değer türü kullanıldığından b'nin değeri artırılmış olmaz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a = 10;
		int b;
		
		b = a;
		
		System.out.printf("a = %d%n", a); //10
		System.out.printf("b = %d%n", b); //10
		System.out.println("***************************************");
		
		++a;
		
		System.out.printf("a = %d%n", a); //11
		System.out.printf("b = %d%n", b); //10
		System.out.println("***************************************");
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte değer türü kullanıldığından b'nin değeri artırılmış olmaz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.a = 20;
		s.b = true;
		
		k.a = 55;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
		s = k;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
		++s.a;
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
		s = new Sample();
		
		--s.a;
		
		System.out.printf("s.a = %d%n", s.a);
		System.out.printf("s.b = %b%n", s.b);
		System.out.printf("k.a = %d%n", k.a);
		System.out.printf("k.b = %b%n", k.b);
		System.out.println("************************");
		
	}
}

class Sample{
	public int a;
	public boolean b;
	
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Bir metodun geri dönüş değeri referans olabilir. Bu durumda bu metodun geri dönüş değerine ilişkin return deyimine
	ait ifadenin türünün aynı türden bir referans olması gerekir. Bir metodun parametre değişkeni bir referans olabilir. 
	Bu durumda metot aynı türden bir referans ile çağrılabilir. Metoda geçilen referans ile metot içerisinde ilgili nesneye
	erişilmiş olur. Referans parametreli bir metot aldığı referansa ilişkin nesne üzerinde değişiklik yapabilir. Bu durumda
	bu değişiklik metodu çağıran kodda ki referans üzerinden yine aynı nesneye erişildiği için görülebilir
	
	Aşağıdaki örnekte createDate metodu içeride yaratmış olduğu nesnenin referansını geri dönüş değeri olarak vermektedir.
	printDate metodu parametresi ile aldığı Date türden referansın gösterdiği nesneye erişip bilgilerini ekrana yazdırmaktadır.
	changeDate metodu aldığı referansa ilişkin nesneye erişerek day, month ve year elemanlarını değiştirmiştir. Örneği 
	çalıştırarak durumu	gözlemleyiniz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Date birtDate;
		
		birtDate = DateUtil.createDate(11, 9, 1990);
		
		DateUtil.printDate(birtDate);
		DateUtil.changeDate(birtDate, 5, 3, 2021);
		DateUtil.printDate(birtDate);
		
	}
}

class DateUtil{
	public static void changeDate(Date d, int day, int month, int year) 
	{
		//..
		d.day = day;
		d.month = month;
		d.year = year;
	}
	
	public static Date createDate(int day, int month, int year)
	{
		Date d = new Date();
		d.day = day;
		d.month = month;
		d.year = year;
		
		return d;
	}
	
	public static void printDate(Date d)
	{
		System.out.printf("%02d/%02d/%04d%n", d.day, d.month, d.year);
		System.out.println("****************************************");
	}

}

class Date{
	public int day, month, year;
	//..
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örneği inceleyiniz

----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Date birtDate;
		
		birtDate = new Date();
		birtDate.day = 23;
		birtDate.month = 06;
		birtDate.year = 1992;
		
		DateUtil.printDate(birtDate);
		
		DateUtil.changeDate(birtDate, 24, 10, 1997);
		
		DateUtil.printDate(birtDate);
		
		
		Date newDate = DateUtil.createDate(13, 02, 2002);
		
		DateUtil.printDate(newDate);
		
		DateUtil.changeDate(newDate, 11, 01, 2022);
		
		DateUtil.printDate(newDate);
		
		newDate = birtDate; //artık iki referans ta aynı adresi temsil eder

		DateUtil.printDate(newDate);
		DateUtil.printDate(birtDate);
	}
}

class DateUtil{
	public static void changeDate(Date d, int day, int month, int year) 
	{
		//..
		
		d.day = day;
		d.month = month;
		d.year = year;
	}
	
	public static Date createDate(int day, int month, int year)
	{
		Date d = new Date();
		d.day = day;
		d.month = month;
		d.year = year;
		
		return d;
	}
	
	public static void printDate(Date d)
	{
		System.out.printf("%02d/%02d/%04d%n", d.day, d.month, d.year);
		System.out.println("****************************************");
	}

}

class Date{
	public int day, month, year;
	//..
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte main içerisindeki yerel değişken olan a'nın değeri metot çağrısından sonra değişmez. Çünkü
	argümanlardan parametrelere aktarım bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a;
		
		a = 20;
		
		Sample.foo(a);
		
		System.out.printf("a = %d%n", a);	
	}
}


class Sample{
	public static void foo(int a) 
	{
		System.out.printf("foo:a = %d%n", a);
		++a;
		System.out.printf("foo:a = %d%n", a);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte main içerisindeki yerel değişken olan a'nın değeri metot çağrısından sonra değişmez. Çünkü
	argümanlardan parametrelere aktarım bir atama işlemidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		int a;
		
		a = 20;
		
		Sample.foo(a);
		
		System.out.printf("a = %d%n", a);
		System.out.println("**************************");
		
		
		/*******************************************/
		
		Mample m = new Mample();
		
		m.a = 14;
		
		Sample.foo(m.a);
		
		System.out.printf("m.a = %d%n", m.a);
		System.out.println("**************************");
		
		
		/*******************************************/
		
		Sample.changeValueMample(m);
		System.out.printf("m.a = %d%n", m.a); //15
	}
}


class Sample{
	public static void foo(int a) 
	{
		System.out.printf("foo:a = %d%n", a);
		++a;
		System.out.printf("foo:a = %d%n", a);
	}
	
	public static void changeValueMample(Mample m) 
	{
		System.out.printf("m.a = %d%n", m.a); //14
		++m.a; //15
		System.out.printf("m.a = %d%n", m.a); //15
	}
}

class Mample{
	int a;
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir veri elemanı bir tanedir. Bu elemanın kullanılması için nesne yaratılması gerekmez. Sınıfın
	static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilebilir. Sınıfın static veri elemanları
	sınıfın bir elemanı ilk kez kullanıldığında yaratılır ve programın sonuna kadar yaşarlar. Ayrıntılar ileride ele
	alınacaktır. Sınıfın static veri elemanlarına da yaratıldıklarında default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);
		
		Sample.a = 10;
		Sample.b = true;
				
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);	
		
	}
}


class Sample{
	public static int a;
	public static boolean b;
}





/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir veri elemanı bir tanedir. Bu elemanın kullanılması için nesne yaratılması gerekmez. Sınıfın
	static bir veri elemanına sınıf dışından sınıf ismi ve nokta operatörü ile erişilebilir. Sınıfın static veri elemanları
	sınıfın bir elemanı ilk kez kullanıldığında yaratılır ve programın sonuna kadar yaşarlar. Ayrıntılar ileride ele
	alınacaktır. Sınıfın static veri elemanlarına da yaratıldıklarında default değerler atanır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);
		
		Sample.a = 10;
		Sample.b = true;
		
		Sample s1 = new Sample();
		s1.c = 12;
		
		Sample s2 = new Sample();
		s2.c = 15;
				
		System.out.printf("Sample.a = %d%n", Sample.a);
		System.out.printf("Sample.b = %b%n", Sample.b);	
		
		
		System.out.printf("s1.a = %d%n", s1.a);
		System.out.printf("s1.b = %b%n", s1.b);	
		System.out.printf("s1.c = %d%n", s1.c);	
		
		System.out.printf("s1.a = %d%n", s2.a);
		System.out.printf("s1.b = %b%n", s2.b);	
		System.out.printf("s2.c = %d%n", s2.c);
		
		s1.a = 19;
		s2.a = 23;
		System.out.printf("s1.a = %d%n", s1.a);
		System.out.printf("s2.a = %d%n", s2.a);
	}
}

class Sample{
	public static int a;
	public static boolean b;
	public int c;
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir veri elamanına sınıf dışından sınıf ismi ile erişilemez. Çünkü non-static veri elemanı
	nesneye özeldir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample.a = 10; // non static oldugu için gecersiz
		
	}
}


class Sample{
	public int a;
	public boolean b;
}




-----------------------------------------------------------
-----------------------------------------------------------

18.01.2023 Çarşamba - 17.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir veri elemanına sınıf dışından referans ve nokta operatörü ile de erişilebilir. Sınıf ismi ile
	erişmekten farkı yoktur. Sınıfın static veri elemanlarına bu şekilde okunabilirlik açısından tercih edilmemelidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.a = 10;
		s.b = true;
		
		System.out.printf("s.a = %d%n", Sample.a);
		System.out.printf("s.b = %b%n", Sample.b);
	}
}


class Sample{
	public static int a;
	public static boolean b;
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte sayaçlar, sınıfları kullanan programcı tarafından oluşturulmuştur. Programcı sayacı artırmayı
	veya azaltmayı unutabilir. Ayrıca başka sınıflar ve dolayısıyla nesneler için de sayaç tutulması gerektiğinde sayaç
	için kullanılacak değişkenlere isim bulma zorluğu oluşabilir. Üstelik oyun bir çok başka işlem de içerdiğinden
	programlaması karmaşıklaşabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		WarGameApp.run();
	}
}

class WarGameApp{
	public static void run() 
	{
		int soldierCount = 0, alienCount = 0;
		
		for (int i = 0; i < 10; i++) {
			Alien a = new Alien();
			
			//
			
			++alienCount;
		}
		
		for (int i = 0; i < 20; i++) {
			Soldier s = new Soldier();
			
			//
			
			++soldierCount;
		}
		
		///
		
		System.out.printf("Number of Soldiers : %d%n", soldierCount);
		System.out.printf("Number of Aliens : %d%n", alienCount);
		
	}
}

class Soldier{
	public int title;
	public int numberOfGuns;
}

class Alien{
	public int numberOfArms;
	public int color;
}

class Building{
	
}

class Civilian{
	
}

class Animal{
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Yukarıdaki örnekte anlatılan problemler aşağıdaki gibi static veri elemanları kullanılarak çözülebilir. Böylece kod
	karmaşıklığı da azaltılmış olur. Şüphesiz örnekte detaylar göz ardı edilmiştir. Burada anlatılmak istenen konulara
	odaklanmanız önerilir. ** ile belirtilen kod parçaları şu an için önemsizdir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		WarGameApp.run();
	}
}

class WarGameApp{
	public static void run() 
	{	
		for (int i = 0; i < 10; i++) {
			Alien a = new Alien();
			
			//
			
		}
		
		for (int i = 0; i < 20; i++) {
			Soldier s = new Soldier();
			
			//

		}
		
		
		///
		
		System.out.printf("Number of Soldiers : %d%n", Soldier.count);
		System.out.printf("Number of Aliens : %d%n", Alien.count);
		
	}
}

class Soldier{
	public static int count;
	public int title;
	public int numberOfGuns;
	
	public Soldier() //***
	{
		++count;
	}
}

class Alien{
	public int numberOfArms;
	public int color;
	public static int count;
	
	public Alien()//***
	{
		++count;
	}
}

class Building{
	public static int count;
	
}

class Civilian{
	public static int count;
	
}

class Animal{
	public static int count;
	
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu sınıf dışından referans ve nokta operatörü ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.foo();
	}
}

class Sample{
	public void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu sınıf dışından sınıf ismi ve nokta operatörü ile çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample.foo(); //error
	}
}

class Sample{
	public void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu sınıf dışından sınıf ismi ve nokta operatörü ile çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample.foo(); //error
	}
}

class Sample{
	public static void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu sınıf dışından referans ve nokta operatörü ile çağrılabilir. Sınıf ismi ile çağırmaktan
	farkı yoktur. Sınıfın static metotlarının bu şekilde çağrılması okunabilirlik açısından tercih edilmemelidir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s = new Sample();
		
		s.foo(); //olur ama kullanmayın 
		
		Sample.foo(); //bu daha uygun
	}
}

class Sample{
	public static void foo()
	{
		//
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın non-static bir veri elemanına doğrudan erişilebilir. Doğrudan 
	erişilen veri elamanı metot çağrısında kullanılan referansın gösterdiği nesnenin veri elemanı olur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		k.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
	}
}

class Sample{
	public int x;
	
	public void foo(int a)
	{
		x = a;
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın non-static bir metodu doğrudan çağrılabilir. Doğrudan çağrılan
	metot, çağıran metodu çağıran referans ile çağrılmış olur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		k.foo(20);
		
		System.out.printf("s.x = %d%n", s.x);
		System.out.printf("k.x = %d%n", k.x);
		
	}
}

class Sample{
	public int x;
	
	public void foo(int a)
	{
		bar(a);
	}
	
	public void bar(int a)
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
	Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın 
    non-static elemanlarına (member) doğrudan erişilebilir

----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın static bir veri elemanına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public static int x;
	
	public void foo(int a)
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın non-static bir metodu içerisinde o sınıfın static bir metodu doğrudan çağrılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public static int x;
	
	public void foo(int a)
	{
		x = a;
		bar(a);
	}
	
	public static void bar(int a)
	{
		System.out.println("bar");
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın 
    static elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki dört maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın 
   	tüm elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın non-static bir veri elemanına doğrudan erişim yoktur
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public int x;
	
	public static void foo(int a)
	{
		x = a; //error
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın non-static bir metodu doğrudan çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s, k;
		
		s = new Sample();
		k = new Sample();
		
		s.foo(10);
		System.out.printf("s.x = %d%n", Sample.x);
		k.foo(20);
		System.out.printf("k.x = %d%n", Sample.x);
		
	}
}

class Sample{
	public int x;
	
	public static void foo(int a)
	{
		bar(a);
	}
	
	public void bar(int a) 
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın static bir metodu içerisinde aynı sınıfın 
    non-static elemanlarına doğrudan erişilemez
---------------------------------------------------------------------------------------------------------------------*/




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın static bir veri elemanına doğrudan erişilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{

		Sample.foo(10);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample{
	public static int x;
	
	public static void foo(int a)
	{
		x = a;
	}

}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıfın static bir metodu içerisinde o sınıfın non-static bir metodu doğrudan çağrılamaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{

		Sample.foo(10);
		System.out.printf("Sample.x = %d%n", Sample.x);
	}
}

class Sample{
	public static int x;
	
	public static void foo(int a)
	{
		bar(a);
	}

	public static void bar(int a)
	{
		x = a;
	}

}




/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki iki maddenin özeti olarak şu söylenebilir: Sınıfın static bir metodu içerisinde aynı sınıfın 
    static elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki dört maddenin özeti olarak şu söylenebilir: Sınıfın static bir metodu içerisinde aynı sınıfın 
    yalnızca static elemanlarına doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Yukarıdaki sekiz maddenin özeti olarak şu söylenebilir: Sınıfın non-static bir metodu içerisinde aynı sınıfın tüm
    elemanlarına doğrudan erişilebilirken, static bir metodu içerisinde aynı sınıfın yalnızca static elemanlarına 
    doğrudan erişilebilir
---------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte bar metodunun doğrudan çağrılmadığına dikkat ediniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
	}
}

class Sample{
	public int x;
	
	public static void foo(int a)
	{
		Sample s = new Sample();
		s.bar(a);
	}

	public void bar(int a)
	{
		x = a;
	}

}


/*----------------------------------------------------------------------------------------------------------------------	 
	Soru: Bir sınıfın metodunun non-static mi, static mi olduğuna nasıl karar vereceğiz?
	
	Cevap: Bu soru için basit bir kural şu şekilde benimsenebilir: "Bir metot non-static elemanlara doğrudan erişmeyecekse 
	static yapılmalıdır". Bu durumda "non-static bir metot için kesinlikle non-static bir elemana doğrudan erişiyordur" 
	anlamı çıkar. Bu da okunabilirliği artırır. Yani aslında "bir metodu yapmak non-static metotların okunabilirliğini
	artırır". Ayrıca non-static metotların sınıf dışında referans ve nokta operatörü ile çağrılması gerektiğinden static
	yapılabilecek olan ancak non-static bir metot boşu boşuna referans ile çağrılmış olur. 
----------------------------------------------------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerini bulup ekrana yazdıran
	programı yazınız. 
	
	
	Sınıfın aşağdaki kullanım şekli sınıfların yararı 100 birim düşünülürse %1 civarındadır. Şüphesiz örnek farklı 
	yaklaşımlarla da yazılabilir. Sınıfın kullanımını göstermek için yazılmıştır. İleride daha iyisi yazılacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("ikinci dereceden denklemin katsayılarını giriniz : ");
		System.out.print("a : ");
		double a = Double.parseDouble(kb.nextLine());
		System.out.print("b : ");
		double b = Double.parseDouble(kb.nextLine());
		System.out.print("c : ");
		double c = Double.parseDouble(kb.nextLine());
		
		QuadraticEquationRootInfo ri = EquationSolverUtil.findQuadraticEquationRoots(a, b, c);
		
		if(ri.exists)
			System.out.printf("x1 = %f, x2 = %f%n", ri.x1, ri.x2);
		else
			System.out.println("Gerçek kök yok.....");
	}
}

class QuadraticEquationRootInfo{
	public double x1, x2;
	public boolean exists;
}

class EquationSolverUtil{
	public static double getDelta(double a, double b, double c) 
	{
		return b * b - 4 * a * c;
	}
	
	public static QuadraticEquationRootInfo findQuadraticEquationRoots(double a, double b, double c) 
	{
		double delta = getDelta(a, b, c);
		QuadraticEquationRootInfo ri = new QuadraticEquationRootInfo();
		
		if(delta >= 0) {
			double sqrtDelta = Math.sqrt(delta);
			ri.x1 = (-b + sqrtDelta) / (2 * a);
			ri.x2 = (-b - sqrtDelta) / (2 * a);
			ri.exists = true;
		}
		
		return ri;
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Point p1, p2;
		
		p1 = new Point();
		p2 = new Point();
		
		p1.x = 10;
		p1.y = 20;
		p2.x = 15;
		p2.y = 25;
		
		p1.print();
		p2.print();
		
		int x = 13, y = 16;
		
		double d;
		
		d = p1.distance(x, y);
		
		System.out.printf("Distance : %f%n", d);
		
		d = p1.distance(p2);
		
		System.out.printf("Distance : %f%n", d);
		
		d = p1.distance();
		
		System.out.printf("Distance : %f%n", d);
	}
}


class Point{
	public int x;
	public int y;
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
19.01.2023 Perşembe - 18.Ders

/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfının parametresiz nextInt metodu int türü sınırları içerisinde rasgele üretilmiş bir sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.println(r.nextInt());
		}
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfının int parametreli nextInt metodyu [0, bound) aralığında rasgele üretilmiş int türden bir sayıya 
	geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(100)); //[0, 100]
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfında Java 17 ile birlikte dolaylı olarak iki tane int türden parametreli bir nextInt metodu da vardır.
	Anahtar Notlar: Java 17 ile birlikte RandomGenerator denilen bir arayüz (interface) eklenmiştir. Random sınıfı da 
	bu arayüzü desteklemektedir (implements). Bu arayüzle birlikte bir çok yeni meotot da Random sınıfına eklenmiştir.
	Arayüz kavramı ve anlatılan kısımların detayları ileride ele alınacaktır. Şu an için bu metotların Random sınıfına
	ait olduğunun bilinmesi yeterlidir 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(20, 100)); //[20, 100]
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Java 17 öncesinde [a, b) aralığında rasgele sayı üretimi
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayiyi giriniz: ");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayiyi giriniz: ");
		int b = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(b -a) + a); //[a, b)
		}
		
		System.out.println();
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	 Java 17 öncesinde [a, b] aralığında rasgele sayı üretimi
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayiyi giriniz: ");
		int a = Integer.parseInt(kb.nextLine());

		System.out.print("İkinci sayiyi giriniz: ");
		int b = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d ", r.nextInt(b -a + 1) + a); //[a, b]
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfının nextLong metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d%n", r.nextLong());
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfı Java 17 ile dolaylı olarak eklenen  nextLong metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d%n", r.nextLong(10_000_000_000L));
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfı Java 17 ile dolaylı olarak eklenen  nextLong metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%d%n", r.nextLong(1L, 10_000_000_000L));
		}
		
		System.out.println();
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  Random sınıfının nextDouble metodu [0, 1) aralığında rasgele üretilmiş double türden bir sayıya geri döner
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%f%n", r.nextDouble()); [0,1)
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfının Java 17 ile dolaylı olarak eklenen nextDouble metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%f%n", r.nextDouble(5));
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Random sınıfının Java 17 ile dolaylı olarak eklenen nextDouble metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%f%n", r.nextDouble(3.14, 6.18));
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	  Random sınıfının nextBoolean metodu
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.printf("%b%n", r.nextBoolean());
		}
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: Hilesiz bir paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir 
	simülasyon programı yazınız
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		CoinSumilation cs = new CoinSumilation();
		
		for(;;) {
			System.out.print("Parayi kac kez atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			cs.run(n);
			
			System.out.printf("Yazı gelme olasiliği: %f%n", cs.p);
		}
	}
}


class CoinSumilation{
	public double p;
	
	public static int getTailCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			count += r.nextInt(2);
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getTailCount(n) / (double)n;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: Hilesiz bir paranın yazı gelme olasılığının yaklaşık olarak 0.5 olduğunu bulan basit bir 
	simülasyon programı yazınız
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		CoinSumilation cs = new CoinSumilation();
		
		for(;;) {
			System.out.print("Parayi kac kez atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			cs.run(n);
			
			System.out.printf("Yazı gelme olasiliği: %f%n", cs.p);
		}
	}
}


class CoinSumilation{
	public double p;
	
	public static int getTailCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			if(r.nextBoolean())
				++count;
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getTailCount(n) / (double)n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: İki zar atıldığında zarların (ikisinin de aynı) olasılığının yaklaşık olarak 
	hesaplayan simülasyon programını yazınız
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		SameDiceSumilation ds = new SameDiceSumilation();
		
		for(;;) {
			System.out.print("Kaç kez zar atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			ds.run(n);
			
			System.out.printf("Çift gelme olasiliği: %f%n", ds.p);
		}
	}
}


class SameDiceSumilation{
	public double p;
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(1, 7) == r.nextInt(1, 7); //java 17
	}
	
	public static int getSameCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			if(areSame(r))
				++count;
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getSameCount(n) / (double)n;
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	  Sınıf Çalışması: İki zar atıldığında zarların (ikisinin de aynı) olasılığının yaklaşık olarak 
	hesaplayan simülasyon programını yazınız
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		CoinSimulationApp.run();
	}
}

class CoinSimulationApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		SameDiceSumilation ds = new SameDiceSumilation();
		
		for(;;) {
			System.out.print("Kaç kez zar atmak istiyorsunuz?");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0)
				break;
			
			ds.run(n);
			
			System.out.printf("Çift gelme olasiliği: %f%n", ds.p);
		}
	}
}


class SameDiceSumilation{
	public double p;
	
	public static boolean areSame(java.util.Random r)
	{
		return r.nextInt(6) + 1 == r.nextInt(6) + 1;
	}
	
	public static int getSameCount(int n) 
	{
		java.util.Random r = new java.util.Random();
		int count = 0;
		
		for (int i = 0; i < n; i++) {
			if(areSame(r))
				++count;
		}
		
		return count;
	}
	
	public void run(int n) 
	{
		p = getSameCount(n) / (double)n;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	 Tohum değeri setSeed metodu ile değiştirilebilir. Aşağıdaki örnek her çalıştırıldığında aynı dizilim elde edilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		java.util.Random r = new java.util.Random();
		
		r.setSeed(1500);
		
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(0, 100));
		
		
		System.out.println();
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	 Aşağıdaki örnekte rasgele üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olur. İlk 10 sayının diziliminin
	 aynı gelme olasılığı çok düşüktür. İkinci üretilen 10 sayı klavyeden alınan tohum değerine göre üretilir. Bu durumda
	 örneğin her çalıştırmada tohum değeri 100 olarak girilirse ikinci 10 sayının dizilimi hep aynı olacaktır. Kodu 
	 çalıştırıp sonucu gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz :");
		long seed = Long.parseLong(kb.nextLine());
				
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(0, 100));
		
		System.out.println();
		
		r.setSeed(seed);
		
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(0, 100));
		
		System.out.println();
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	 Aşağıdaki örnekte rasgele üretilen ilk 10 sayının dizilimi her çalıştırmada farklı olur. İlk 10 sayının diziliminin
	 aynı gelme olasılığı çok düşüktür. İkinci üretilen 10 sayı klavyeden alınan tohum değerine göre üretilir. Bu durumda
	 örneğin her çalıştırmada tohum değeri 100 olarak girilirse ikinci 10 sayının dizilimi hep aynı olacaktır. Kodu 
	 çalıştırıp sonucu gözlemleyiniz 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		
		java.util.Random r = new java.util.Random();
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;){
			
			System.out.print("Kaç tane nokta üretilsin:");
			int count = Integer.parseInt(kb.nextLine());
			
			if(count <= 0)
				break;
			
			System.out.print("Minimum deger giriniz: ");
			int a = Integer.parseInt(kb.nextLine());
			
			System.out.print("Maksimum deger giriniz: ");
			int b = Integer.parseInt(kb.nextLine());
			
			
			System.out.println("------------------------------------");
			for (int i = 0; i < count; i++) {
				Point p = RandomPointGenerator.randomPoint(r, a, b);
				
				p.print();
			}
			System.out.println("------------------------------------");
		}
		
	}
}

class RandomPointGenerator{
	public static Point randomPoint(java.util.Random r, int a, int b) 
	{
		Point p = new Point();
		
		p.x = r.nextInt(a, b + 1);
		p.y = r.nextInt(a, b + 1);
		
		return p;
	}
}

class Point{
	public int x;
	public int y;
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Math sınıfının random metodu [0, 1) aralığında rasgele üretilmiş double türden bir değere geri döner. Bu metot 
	içsel olarak her çağıramda aynı Random nesnesini kullanır. Bu metot ilk kez çağrıldığında kullandığı Random
	nesnesi yaratılır ve her çağrıda bu nesne kullanılır. Aşağıdaki örneğin yaklaşık eşdeğeri:
	 
	 
	 java.util.Random r = new java.util.Random();
	
	 for (int i = 0; i < 10; ++i)
		System.out.println(r.nextDouble());
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random();
		
		for (int i = 0; i < 10; i++) {
			System.out.println(Math.random());
		}
		
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Nesne yaratılma adımları:
	1. Bellekten yer ayrılır
	2. non-static olan (ancak final olmayan) veri elemanlarına default degerler atanır
	3. Constructor (ctor) çağrılır
	
	Bu üç adımın sonunda new operatörünün ürettiği deger yani nesnenin adresi(referans) elde edilir.
	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	ctor aşağıdaki özelliklere sahip bir metottur:
	- Sınıfı yazan programcı sınıfa hiçbir ctor yazmazsa parametresiz ctor'u (default ctor) derleyici tarafından içi
	boş ve public olarak yazılır.
	
	- Sınıfı yazan programcı en az bir tane ctor yazarsa default ctor derleyici tarafından yazılmaz. Artık default
	ctor'un yazılıp yazılmayacağına programcı karar verecektir
	
	- ctor overload edilebilir (constructor overloading)
	
	- Sınıfın ctor'u sınıf ismi ile aynı olan ve geri dönüş değeri kavramı olmayan bir metottur. Geri dönüş değeri bilgisi
	yazılmaz. void da yazılmaz. Sınıf ismi ile aynı isimde bir metot yazılıp geri dönüş değeri bilgisi yazılırsa artık 
	bu metot ctor olmaz. Şüphesiz bu şekilde bir metot yazılmamalıdır
	
	- ctor non-static bir metottur
	
	- ctor new operatörü ile nesne yaratılması sırasında çağrılır. Hangi ctor'un çağrılacağı derleme zamanında new operatörü
	ile kullanımda geçilen argümanlara göre "method overload resolution" kurallarına göre belirlenir.
	
	- Programcı ctor'u çağıramaz. Programcı new operatörü ile ilgili ctor'un ÇAĞRILACAĞI kodun derleyici tarafından
	üretilmesini sağlar.
	
	- ctor'dan önce non-static ve final olmayan veri elemanlarına default değerler atanmış olur 
	
	- ctor içerisinde return tek başına ctor'u sonlandırmak amaçlı kullanılabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2, s3, s4, s5;
		
		s1 = new Sample();
		s2 = new Sample(10);
		s3 = new Sample(3.4);
		s4 = new Sample(3.4f);
		s5 = new Sample(10, 1000000L);
		
	}
}

class Sample{
	public Sample() //default ctor
	{
		System.out.println("default ctor");
	}
	
	public Sample(int a) 
	{
		System.out.println("ctor has a int parameter");
	}
	
	public Sample(float a)
	{
		System.out.println("ctor has a float parameter");
	}
	
	public Sample(double a)
	{
		System.out.println("ctor has a double parameter");
	}
	
	public Sample(int a, long b)
	{
		System.out.println("ctor has int and long parameter");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Sample sınıfını yazan programcı int parametreli bir ctor yazdığı için derleyici artık default 
	ctor'u yazmaz. Default ctor'un olması artık sınıfı yazan programcının karar vermesi gereken bir durumdur
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1,s2;
		
		s1 = new Sample(); //error
		s2 = new Sample(10);

		
	}
}

class Sample{
	public Sample(int a) 
	{
		System.out.println("ctor has a int parameter");
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	ctor'dan önce non-static ve final olmayan veri elemanlarına default değerler atanmış olur
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2, s3;
		
		s1 = new Sample();
		System.out.println("-------------------------------");
		s2 = new Sample(10, true);
		System.out.println("-------------------------------");
		s3 = new Sample(20);

		
	}
}

class Sample{
	public int x;
	public boolean y;
	
	public Sample() 
	{
		System.out.printf("x = %d, y = %b%n", x, y);
	}
	
	public Sample(int a, boolean b) 
	{
		System.out.printf("x = %d, y = %b%n", x, y);
	}
	
	public Sample(int a) 
	{
		System.out.printf("x = %d, y = %b%n", x, y);
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	ctor içerisinde birçok işlem yapılabilir. ctor'un temel işlevi nesne yaratıldığı noktada bir takım ilk işlemlerin
	o nesne için yapılmasını sağlamaktır. Bun ilk işlemlerdeen en çok karşılaşılanı ctor içerisinde non-static veri
	elemanlarına değer verilmesidir. Bu durumda nesne yaratıldığı zaman non-static veri elemanları istenen değerde
	gelmiş olur 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2, s3;
		
		s1 = new Sample();
		s2 = new Sample(10, true);
		s3 = new Sample(20);
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
		System.out.printf("s3.x = %d, s3.y = %b%n", s3.x, s3.y);
	}
}

class Sample{
	public int x;
	public boolean y;
	
	public Sample() 
	{
	}
	
	public Sample(int a, boolean b) 
	{
		x = a;
		y = b;
	}
	
	public Sample(int a) 
	{
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	ctor içerisinde istenirse return tek başşına ctor'u sonlandırmak için kullanılabilir. Örnekte konuyu anlatmak için
	kod bu şekilde yazılmıştır 
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		Sample s1, s2;
		
		s1 = new Sample(10);
		s2 = new Sample(-20);
		
		System.out.printf("s1.x = %d, s1.y = %b%n", s1.x, s1.y);
		System.out.printf("s2.x = %d, s2.y = %b%n", s2.x, s2.y);
	}
}

class Sample{
	public int x;
	public boolean y;
	
	public Sample(int a) 
	{
		if(a >= 0)
			return;
		
		x = a;
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Random sınıfının tohum değeri parametreli ctor'u. Tohum değeri parametreli ctor ile aşağıdaki şu işlem bir hamlede
	yapılmış olur:
	
	java.util.Random r = new java.util.Random();
	
	r.setSeed(100);
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{
		java.util.Random r = new java.util.Random(100);
		
		for (int i = 0; i < 10; i++) 
			System.out.printf("%d ", r.nextInt(100));
		
		System.out.println();
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Anahtar Notlar: Sınıfı yazan programcı default dışında bir ctor yazdığında default ctor'u yazıp yazmayacağına nasıl 
	karar verecektir? Aslında bu, yazılan sınıfa bağlıdır. Bunun için başlangıç düzeyinde şu soru sorulabilir:
	"Bu sınıf türünden nesnenin default durumu var mı?" Örneğin Random sınıfının default ctor'u bu nesnenin default
	durumudur. Yani tohum değerini her default ctor çağrısında mümkün olduğunca farklı verecek şekilde bir nesnenin
	yaratılmasını sağlamaktır. Ancak bazı özel durumlarda sınıfı kullanan başka sınıflar ya da ortamlar (framework) 
	default ctor olmasını isteyebilirler. Bu durumda programcı default ctor'u yazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Point sınıfı inceleme
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Point p1, p2, p3;
		
		p1 = new Point();
		p2 = new Point(100);
		p3 = new Point(100, 200);
		
		p1.print();
		p2.print();
		p3.print();
	}
}

class Point{
	public int x;
	public int y;
	
	public Point()
	{
	}
	
	public Point(int a)
	{
		x = a;
	}
	
	public Point(int a, int b)
	{
		x = a;
		y = b;
	}
	
	public double distance() 
	{
		return distance(0, 0);
	}
	
	public double distance(Point other) 
	{
		return distance(other.x, other.y);
	}
	
	public double distance(int a, int b) 
	{
		return Math.sqrt(Math.pow(x - a, 2) + Math.pow(y - b, 2));
	}
	
	public void offset(int dx, int dy)
	{
		x += dx;
		y += dy;
	}
	
	public void print()
	{
		System.out.printf("(%d, %d)%n", x, y);
	}
}





/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex();
		Complex z2 = new Complex(-3, 4.56);
		Complex z3 = new Complex(4.3);
		
		z1.print();
		z2.print();
		z3.print();
	}
}


class Complex{
	public double real;
	public double imag;
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(2, 5);
		Complex z2 = new Complex(-3, 4.56);
		Complex z;
		

		z = z1.add(z2);
		z.print();
		
		z = z1.add(3.4);
		z.print();
		
		z = Complex.add(3.5, z1);
		z.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2)
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------

24.01.2023 Salı - 19.Ders


/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(5, 10);
		Complex z2 = new Complex(-7, 20.56);
		Complex z;
		

		z = z1.subtract(z2);
		z.print();
		
		z = z1.subtract(3.4);
		z.print();
		
		z = Complex.subtract(3.5, z1);
		z.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(5, 10);
		Complex z2 = new Complex(-7, 20.56);
		Complex z;
		

		z = z1.multiply(z2);
		z.print();
		
		z = z1.multiply(3.4);
		z.print();
		
		z = Complex.multiply(3.5, z1);
		z.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Complex sınıfı
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{		
		Complex z1 = new Complex(5, 10);
		
		z1.inc(3);
		z1.print();
		z1.dec(3);
		z1.print();
		z1.inc();
		z1.print();
		//Complex z2 = z1.getComjugate();
		//z2.print();
		
		z1.getComjugate().print();
		z1.print();
		
	}
}


class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}




/*----------------------------------------------------------------------------------------------------------------------	 
	String Literal - string sabiti
	
	Derleyici bir String sabitini (string literal) gördüğünde ve bu string sabitinin özdeşini daha önce görmemişse 
	şöyle bir kod üretir: "Çalışma zamanında String türden bir nesne yarat, karakterlerini bu nesneye aktar ve o
	nesnenin referansını (adresini) ver"
	
	print ve println metotlarının String parametreli overload'ları argüman olarak aldıkları String referansına 
	ilişkin yazıyı ekrana basarlar
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s;
		
		s = "istanbul";
		
		System.out.println(s);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	printf metodunda s format karakteri ile String referansına ilişkin yazı formatlanıp ekrana basılabilir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s;
		
		s = "istanbul";
		
		System.out.printf("Yazı: %s%n", s);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Scanner sınıfının nextLine metodu ile klavyeden bir yazı alınabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir yazı giriniz: ");
		String s = kb.nextLine();
		
		System.out.printf("Yazı: %s%n", s);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Immutable class: Bir nesnenin non-static veri elemanları sınıfı kullanan programcı tarafından değiştirilemiyor
	ise bu tarz sınıflara "immutable class" denir. Immutable sınıfların nasıl yazılabileceği ileride ele alınacaktır.
	immutable sınıfların avantajlı ve dezavantajlı durumları vardır. Bunlar da zamanla anlaşılacaktır
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte Complex sınıfı türünden bir nesnenin real veri elemanı değiştirilmiştir. Yani nesnenin içeriği
	değiştirilebilir. Dolayısıyla bu sınıf "immutable" bir sınıf değildir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		Complex z = new Complex(33, 11);
		
		z.print();
		
		z.real *= 2;
		
		z.print();
		
	}
}

class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}


/*----------------------------------------------------------------------------------------------------------------------	 
	İki aynı türden referans == ve != operatörü ile karşılaştırılabilir. Bu karşılaştırma adres (referans) karşılaştırmasıdır.
	Bu durumda == operatörü iki referans da aynı nesneyi gösteriyorsa true, göstermiyorsa false değerini üretir. Benzer 
	şekilde != operatörü iki referans da aynı nesneyi gösteriyorsa false, göstermiyorsa true değerini üretir. 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		Complex z1, z2;
		z1 = new Complex(3, 4);
		z2 = z1; //new Complex(3, 4);
		
		System.out.println(z1 == z2 ? "Aynı nesne" : "Farklı nesne");
		System.out.println(z1 != z2 ? "Farklı nesne" : "Aynı nesne");
		
	}
}

class Complex{
	public double real;
	public double imag;
	
	public static Complex add(double a1, double b1, double a2, double b2) //ileride bu metot gizlenecek
	{
		return new Complex(a1 + a2, b1 + b2);
	}

	public static Complex subtract(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return add(a1, b1, -a2, -b2);
	}
	
	public static Complex multiply(double a1, double b1, double a2, double b2)  //ileride bu metot gizlenecek
	{
		return new Complex(a1 * a2 - b1 * b2, a1 * b2 + a2 * b1);
	}
	
	public Complex()
	{
	}
	
	public Complex(double re)
	{
		real = re;
	}
	
	public Complex(double re, double im)
	{
		real = re;
		imag = im;
	}
	
	public double getNorm()
	{
		return Math.sqrt(real * real + imag * imag);
	}
	
	public double getLength()
	{
		return getNorm();
	}
	
	public Complex getComjugate()
	{
		return  new Complex(real, -imag);
	}
	
	public static Complex add(double value, Complex z) 
	{
		return add(value, 0, z.real, z.imag);
	}
	
	public Complex add(Complex other)
	{
		return add(real, imag, other.real, other.imag);
	}
	
	public Complex add(double value)
	{
		return add(real, imag, value, 0);
	}
	
	public static Complex subtract(double value, Complex z)
	{
		return subtract(value, 0, z.real, z.imag);
	}
	
	public Complex subtract(Complex other)
	{
		return subtract(real, imag, other.real, other.imag);
	}
	
	public Complex subtract(double value)
	{
		return subtract(real, imag, value, 0);
	}
	
	public static Complex multiply(double value, Complex z)
	{
		return multiply(value, 0, z.real, z.imag);
	}
	
	public Complex multiply(Complex other)
	{
		return multiply(real, imag, other.real, other.imag);
	}
	
	public Complex multiply(double value)
	{
		return multiply(real, imag, value, 0);
	}
	
	public void inc(double value)
	{
		real += value;
	}
	
	public void inc()
	{
		inc(1);
	}
	
	public void dec(double value)
	{
		inc(-value);
	}
	
	public void dec()
	{
		dec(1);
	}
	
	public void print()
	{
		System.out.printf("|%.2f, %.2f| = %f%n", real, imag, getNorm());
	}
	
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfı immutable bir sınıftır. Yani String nesnesine ilişkin yazı üzerinde değişiklik yapılamaz. Yazı 
	üzerinde değişiklik yapan metotlar değişiklik yapılmış yazıyı içeren yeni bir String nesnesinin referansına geri
	dönekler. Örneğin bir yazının tamamını büyük harfe çeviren toUpperCase non-static metodu yazı üzerinde değişiklik
	yapamayacağı için tamamı büyük harflerden oluşan yazıyı içeren yeni bir String referansına geri döner 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının toUpperCase metodu 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		String upper = s.toUpperCase();
		
		System.out.println(s);
		System.out.println(upper);
		
		System.out.println(s == upper ? "Aynı nesne" : "Farklı nesne");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfı immutable bir sınıftır. Yani String nesnesine ilişkin yazı üzerinde değişiklik yapılamaz. Yazı 
	üzerinde değişiklik yapan metotlar değişiklik yapılmış yazıyı içeren yeni bir String nesnesinin referansına geri
	dönekler. Örneğin bir yazının tamamını büyük harfe çeviren toUpperCase non-static metodu yazı üzerinde değişiklik
	yapamayacağı için tamamı büyük harflerden oluşan yazıyı içeren yeni bir String referansına geri döner 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının toUpperCase metodu 
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		String upper = s.toLowerCase();
		
		System.out.println(s);
		System.out.println(upper);
		
		System.out.println(s == upper ? "Aynı nesne" : "Farklı nesne");
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki örnekte mantıksal olarak değiştirilmiş bir yazı ile akışın devam ettiği bir kod yazılmıştır. Şüphesiz
		s = s.toLowerCase()
	ifadesi toLowerCase metodunun döndürdüğü referensın s'ye atanmasıdır. Bu durumda s artık yeni nesneyi gösterir
	duruma gelir
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		s = s.toLowerCase();
		
		System.out.println(s);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının length isimli metodu ile yazının karakter sayısı elde edilebilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
			
		System.out.printf("Length : %d%n", s.length());
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının charAt metodu ile herhangi bir indeksteki karakter elde edilebilir. Indeks numarası sıfır değerinden
	başlar
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		int length = s.length();
		
		for (int i = 0; i < length; ++i) 
			System.out.printf("%c ", s.charAt(i));
		
		System.out.println();
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının charAt metoduna pozitif ya da negatif bakımdan sınırlar dışında değer verilirse exception oluşur.
	Indeks değerleri [0, length) aralığıdır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir yazı giriniz : ");
		String s = kb.nextLine();
		
		char ch = s.charAt(-4);
		
		System.out.println(ch);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Yazıların eşitlik karşılaştırması == ve != operatörleri ile yapılamaz. Çünkü == ve != karşılaştırması bir referans
	karşılaştırmasıdır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz : ");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz : ");
		String s2 = kb.nextLine();
		
		System.out.println(s1 == s2 ? "Aynı yazı": "Farklı yazılar");
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Yazıların eşitlik karşılaştırması equals metodu ile yapılabilir. Bu metot büyük-küçük harf duyarlı (case sensitive)
	karşılaştırma yapar
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz : ");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz : ");
		String s2 = kb.nextLine();
		
		System.out.println(s1.equals(s2) ? "Aynı yazı": "Farklı yazılar");
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının equalsIgnoreCase metodu ile büyük-küçük harf duyarsız (case insensitive) eşitlik karşılaştıması
	yapılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci yazıyı giriniz : ");
		String s1 = kb.nextLine();
		
		System.out.print("İkinci yazıyı giriniz : ");
		String s2 = kb.nextLine();
		
		System.out.println(s1.equalsIgnoreCase(s2) ? "Aynı yazı": "Farklı yazılar");
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	Derleyici özdeş string sabitleri (string literals) için aynı nesnenin referansını verecek bir kod üretir. Yani bir
	string sabiti ile özdeş kaç tane sabit olursa olsun hepsi için aynı nesnenin referansı elde edilir. Yeniden nesne
	yaratılmaz. Aşağıdaki örnekte yine referans karşılaştırması yapılmıştır. Ancak s1 ve s2'ye atanan string'ler özdeş
	olduğundan aynı adresler tutulmuş olur. Örnek durumu anlatmak için yazılmıştır
	
	Anahtar Notlar: Derleyicinin özdeş string'ler için aynı adresi vermesi String sınıfının immutable olmasındandır. Aksi
	olsaydı yani String sınıfı immutable olmasaydı aynı adres verildiğinde herhangi bir referans üzerinden değişiklik 
	yapılması durumunda diğer referans da değişiklik yapılmış yazıyı görürdü. Bu durumda bu tasarım programcının hatalı 
	kodlar yazma olasılığını artırırdı.
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s1 = "istanbul";
		String s2 = "istanbul";
		
		System.out.println(s1 == s2 ? "Aynı yazı": "Farklı yazılar");
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının yazı içerisinde karakter arayan indexOf metodu
	indexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok çalışmak gerekir!";
		char ch = 'z';
		
		int idx = s.indexOf(ch);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının yazı içerisinde yazı arayan indexOf metodu
	indexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok çalışmak gerekir!";
		String str = "bir";
		
		int idx = s.indexOf(str);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}

/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının yazı içerisinde belirli bir indeksten itibaren yazı arayan indexOf metodu
	indexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok çalışmak gerekir!";
		String str = "bir";
		
		int idx = s.indexOf(str, 3);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının lastIndexOf metotları
	lastIndexOf metotları bulamamaları durumunda -1 değerine geri dönerler
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = "İyi bir programcı olmak için çok bir çok çalışmak gerekir!";
		String str = "bir";
		
		int idx = s.lastIndexOf(str);
		
		System.out.printf("Index : %d%n", idx);
		
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
		int idx = 0;
		
		while((idx = s1.indexOf(s2, idx)) != -1) {
			++count;
			++idx;
		}
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
		int idx = -1;
		
		while((idx = s1.indexOf(s2, idx + 1)) != -1)
			++count;
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
	
		for(int i = 0; (i = s1.indexOf(s2, i)) != -1; ++i, ++count)
			;
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı iki yazıdan birinci içerisinde ikincisinden kaç tane olduğunu döndüren 
	countString isimli metodu ve büyük küçük harf duyarsız olarak çalışan countStringIgnore isimli metodu yazınız ve
	aşağıdaki kod ile test ediniz.
	
	Örneğin
	
	aaa yazısı içerisinde aa dan 2(iki) tane vardır
	
	bbaaa
	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		CountStringTest.run();
	}
}

class CountStringTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Birinci yazıyı giriniz:");
			String s1 = kb.nextLine();
			
			if ("elma".equals(s1))
				break;
			
			System.out.print("İkinci yazıyı giriniz:");
			String s2 = kb.nextLine();
			
			int count = StringUtil.countString(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan %d adet var%n", count);
			count = StringUtil.countStringIgnoreCase(s1, s2);
			System.out.printf("Birinci yazıda ikinci yazıdan büyük küçük harf duyarsız olarak %d adet var%n", count);			
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class StringUtil{
	public static int countString(String s1, String s2)
	{
		int count = 0;
	
		for(int i = -1; (i = s1.indexOf(s2, i + 1)) != -1; ++count)
			;
		
		return count;
	}
	
	public static int countStringIgnoreCase(String s1, String s2)
	{
		return countString(s1.toLowerCase(), s2.toLowerCase());
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	İçerisinde hiçbir karakter bulunmayan yani length bilgisi sıfır olan String'lere boş string denir	
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		String s = ""; //empty string
		
		System.out.printf("Length : %d%n", s.length());
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir String'in boş olup olmadığının test edilmesi (kötü yöntem)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.println("".equals(s) ? "Boş string" : "Boş string değil");
		}
	}
}




/*----------------------------------------------------------------------------------------------------------------------	 
	Bir String'in boş olup olmadığının test edilmesi (kötü yöntem)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.println(s.length() == 0 ? "Boş string" : "Boş string değil");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	BBir String'in boş olup olmadığının test edilmesinin isEmpty metodu ile yapılaması en iyi tekniktir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.println(s.isEmpty() ? "Boş string" : "Boş string değil");
		}
	}
}


/*----------------------------------------------------------------------------------------------------------------------	 
	String sınıfının trim metodu baştaki ve sondaki boşluk (whitespace) karakterlerinin atılmış olduğu yeni bir string
	referansına geri döner. Aradaki boşluklara dokunmaz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);

		for(;;) {
			System.out.print("Bir yazi giriniz:");
			String s = kb.nextLine();
			
			if("elma".equals(s))
				break;
			
			System.out.printf("[%s]%n", s);
			System.out.printf("[%s]%n", s.trim());
		}
	}
}



/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Klavyeden kullanıcı adı ve şifre isteyen basit bir ATM uygulamasının bir parçasını aşağıdaki
	açıklmalara göre yazınız.
	Açıklamalar:
	- Kullanıcı ad ve şifresi en fazla 3(üç) kez denenebilecektir.
	
	- Denemeler sırasında doğru giriş yapılırsa "Giriş başarılı", başarısız denemeler "Giriş başarız" yazısı basılacaktır
	
	- En fazla 3 deneme sonucunde başarısız olunmuşsa "Giriş başarısız. Artık deneme hakkınız biti!..." yazısı basılacaktır
	
	- Uygulama adı ve şifrenin doğruluğu program içerisinde belirlene bir kullanıcı adı ve şifre ile yapılacaktır.
	
	- Uygulama genel düşünerek yazılmalıdır
	
	- ATM uygulamasının sürekli çalıştığı varsayımıyla yazılması önerilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

class App {	
	public static void main(String [] args)
	{	
		AtmApp.run(3);
	}
}

class AtmApp{
	
	public static void doSucces(AtmCard atmCard, java.util.Scanner kb)
	{
		System.out.println("-----------------------------------");
		System.out.println("Giriş başarılı");
		System.out.println("-----------------------------------");
	}
	
	public static void doFail(AtmCard atmCard, java.util.Scanner kb)
	{
		System.out.println("-----------------------------------");
		System.out.println("Giriş başarısız. Artık deneme hakkınız bitti!....");
		System.out.println("-----------------------------------");
	}
	
	public static void doWorkForCard(AtmCard atmCard, int tryNum, java.util.Scanner kb)
	{
		int i = 0;
		
		for (;  i < tryNum; ++i) {
			System.out.print("Kullanıcı adını giriniz : ");
			String username = kb.nextLine();
			System.out.print("Şifrenizi giriniz : ");
			String password = kb.nextLine();
			
			if(atmCard.isvalid(username, password))
				break;
			
			if(i != tryNum - 1)
				System.out.printf("Giriş başarısız. %d giriş hakkınız kaldı!...%n", tryNum -1 - i);
			
		}
		
		if(i != tryNum)
			doSucces(atmCard, kb);
		else
			doFail(atmCard, kb);
		
	}
	
	public static void run(int tryNum)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.println("Hoş geldiniz!...");
			AtmCard atmCard = new AtmCard();
			
			doWorkForCard(atmCard, tryNum, kb);
		}
	}
}


class AtmCard{
	public String username;
	public String password;
	
	public AtmCard()
	{
		username = "orhan";
		password = "2023";
	}
	
	public boolean isvalid(String uname, String passwd)
	{
		return uname.equals(username) && passwd.equals(password);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------
